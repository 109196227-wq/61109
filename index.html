<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ˜Ÿéš›ç¥æ§æ‰‹ V2.0 - éœ“è™¹ç§‘å¹»ç‰ˆ</title>
    
    <!-- è¼‰å…¥ Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        /* --- å…¨å±€æ¨£å¼èˆ‡é…è‰² --- */
        :root {
            --neon-teal: #1effe0;
            --neon-purple: #ff33ff;
            --dark-bg: #03001e;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%);
            color: #e5e7eb;
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 1rem 0; 
            user-select: none; 
            overflow: hidden; 
        }

        #game-container {
            width: 100%;
            max-width: 650px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: transparent; 
            padding: 0 1rem; 
            border: 3px solid var(--neon-teal);
            box-shadow: 0 0 50px rgba(30, 255, 224, 0.4), inset 0 0 20px rgba(30, 255, 224, 0.2); 
            height: 98vh; 
            border-radius: 1rem;
            position: relative;
            overflow: hidden; /* ç¢ºä¿ CRT æ¿¾é¡ä¸æº¢å‡º */
        }

        /* --- CRT å¾©å¤æƒæç·šæ¿¾é¡ --- */
        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                rgba(18, 16, 16, 0) 50%, 
                rgba(0, 0, 0, 0.25) 50%
            ), linear-gradient(
                90deg, 
                rgba(255, 0, 0, 0.06), 
                rgba(0, 255, 0, 0.02), 
                rgba(0, 0, 255, 0.06)
            );
            background-size: 100% 4px, 6px 100%;
            pointer-events: none; /* è®“é»æ“Šç©¿é€æ¿¾é¡ */
            z-index: 10;
            border-radius: 1rem;
        }

        #gameCanvas {
            border: 5px solid var(--neon-teal); 
            background-color: #050505; /* æ¥µæ·±ç°èƒŒæ™¯ */
            box-shadow: 0 0 60px var(--neon-teal), inset 0 0 20px rgba(30, 255, 224, 0.5);
            border-radius: 0.75rem; 
            touch-action: none; 
            cursor: none; 
            width: 100%;
            height: auto;
            flex-grow: 1; 
        }
        
        .neon-title {
            color: var(--neon-teal);
            text-shadow: 0 0 10px var(--neon-teal), 0 0 20px var(--neon-teal), 0 0 30px #00ffff;
            z-index: 20;
        }
        .neon-text-purple {
             color: var(--neon-purple);
            text-shadow: 0 0 8px var(--neon-purple), 0 0 15px var(--neon-purple);
        }

        /* --- æŒ‰éˆ•èˆ‡è³‡è¨Šæ¬„æ¨£å¼ --- */
        .control-btn {
            background: linear-gradient(145deg, var(--neon-teal), #00c8a8);
            color: #000;
            font-weight: 900;
            border: none;
            box-shadow: 0 4px 25px rgba(30, 255, 224, 0.8), 0 0 15px rgba(255, 255, 255, 0.4) inset;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 1px 1px 0 #000;
            position: relative;
            z-index: 20;
        }
        .control-btn:hover:not([disabled]) {
            transform: scale(1.03);
            background: linear-gradient(145deg, #00c8a8, var(--neon-teal));
            box-shadow: 0 6px 30px rgba(30, 255, 224, 1);
        }
        #game-info {
            background-color: #0d011f80;
            border: 2px solid var(--neon-teal);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            backdrop-filter: blur(8px);
            box-shadow: 0 0 15px var(--neon-teal) inset;
            z-index: 20;
        }
        #xp-bar {
            background-color: #34d399;
            box-shadow: 0 0 15px #34d399; /* å¢å¼·å…‰æšˆ */
        }

        /* --- é¸å–®èˆ‡å‡ç´šå¡ç‰‡æ¨£å¼ --- */
        .select-option {
            border: 2px solid #374151;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            transition: all 0.2s;
            cursor: pointer;
            background-color: #0a011a80; 
            backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
        }
        .select-option:hover {
             background-color: #1f293780;
             border-color: #666;
        }
        input[type="radio"]:checked + .select-option { 
             border-color: var(--neon-purple); 
             box-shadow: 0 0 20px var(--neon-purple), inset 0 0 8px rgba(255, 51, 255, 0.5);
             background-color: #5b21b655;
             transform: scale(1.02);
        }
        #message-modal {
            z-index: 50;
        }
        #message-modal > div {
            background-color: rgba(3, 0, 30, 0.95);
            border: 3px solid var(--neon-purple);
            box-shadow: 0 0 50px rgba(255, 51, 255, 0.6);
            max-width: 90%; 
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        #modal-title {
            color: var(--neon-purple);
            text-shadow: 0 0 20px var(--neon-purple);
        }
        .upgrade-card {
            background-color: #0a011a;
            border: 2px solid #374151;
            padding: 1rem;
            border-radius: 0.75rem;
            transition: all 0.2s;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .upgrade-card:hover {
             border-color: var(--neon-teal);
             box-shadow: 0 0 20px var(--neon-teal);
             transform: translateX(5px) scale(1.02);
             background-color: #0f0524;
        }
        
        #skill-button {
            background: linear-gradient(145deg, #a855f7, #9333ea);
            box-shadow: 0 0 25px rgba(168, 85, 247, 0.9);
            z-index: 20;
        }
        #skill-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #4b5563;
            box-shadow: none;
        }
    </style>
</head>
<body class="p-0">

<div id="game-container" class="bg-[var(--dark-bg)]">
    <!-- CRT æ¿¾é¡å±¤ -->
    <div class="crt-overlay"></div>

    <h1 class="text-3xl font-extrabold mt-2 mb-1 neon-title sm:text-4xl italic">ã€Šæ˜Ÿéš›ç¥æ§æ‰‹ V2.0ã€‹</h1>
    <p class="text-xs text-gray-400 mb-2 font-mono z-20">(æ‹–æ›³ç§»å‹• / é»æ“ŠæŒ‰éˆ•æ”¾æŠ€èƒ½)</p>

    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="gameCanvas"></canvas>

    <!-- ç‹€æ…‹è³‡è¨Šé¡¯ç¤º -->
    <div id="game-info" class="flex justify-between w-full max-w-lg mt-3 mb-1 text-xl font-mono px-4">
        <span class="text-[var(--neon-teal)]" style="text-shadow: 0 0 10px var(--neon-teal);">SCORE: <span id="score">0</span></span>
        <span class="text-yellow-400" style="text-shadow: 0 0 10px #FBBF24;">LV: <span id="level">1</span></span>
        <span class="text-red-500" style="text-shadow: 0 0 10px #EF4444;">HP: <span id="lives">3</span></span>
    </div>

    <!-- ç¶“é©—å€¼æ¢ -->
    <div class="w-full max-w-lg px-4 mb-2 z-20">
        <div class="h-2 bg-gray-900 rounded-full border border-gray-700 overflow-hidden">
            <div id="xp-bar" class="h-full rounded-full transition-all duration-200 ease-out" style="width: 0%;"></div>
        </div>
        <div id="xp-text" class="text-xs text-gray-400 text-right mt-1 font-mono">0/5 XP</div>
    </div>

    <!-- æŠ€èƒ½æŒ‰éˆ• -->
    <div class="w-full max-w-lg flex justify-center pb-2 px-4 z-20">
        <button id="skill-button" class="w-full py-3 text-xl font-bold rounded-lg transition duration-150 control-btn flex items-center justify-center gap-2" disabled>
            <span class="animate-pulse">âš¡</span> <span id="skill-name">SKILL</span> (<span id="skill-count">0</span>)
        </button>
    </div>
    
    <!-- éŠæˆ²çµæŸ/é–‹å§‹/å‡ç´š è¨Šæ¯æ¨¡çµ„ -->
    <div id="message-modal" class="fixed inset-0 bg-black bg-opacity-90 flex justify-center items-center hidden">
        <div class="p-6 rounded-2xl text-center w-full max-w-md border-2 border-[var(--neon-purple)]">
            <h2 id="modal-title" class="text-4xl font-extrabold mb-4 neon-text-purple italic tracking-wider">æº–å‚™å‡ºæ“Š</h2>
            <p id="modal-message" class="text-md mb-6 text-cyan-200 font-mono tracking-widest uppercase">SYSTEM READY...</p>
            
            <!-- å•Ÿå‹•/éŠæˆ²çµæŸ é¸å–® -->
            <div id="start-menu" class="text-left mb-6 space-y-5">
                
                <!-- æ­¦å™¨é¸æ“‡å™¨ -->
                <div>
                    <p class="text-lg font-bold mb-3 text-yellow-400 neon-text border-b border-gray-700 pb-1">ä¸»æ­¦å™¨ç³»çµ± [WEAPON]</p>
                    
                    <label for="select-blaster" class="block">
                        <input type="radio" id="select-blaster" name="weapon" value="blaster" class="hidden" checked>
                        <div class="select-option group">
                            <div class="flex items-center justify-between">
                                <span class="font-bold text-[#A855F7] neon-text-purple text-lg">ğŸŸ£ æ¨™æº–é›·å°„ (BLASTER)</span>
                                <span class="text-xs bg-purple-900 text-purple-200 px-2 py-1 rounded">BALANCED</span>
                            </div>
                            <p class="text-xs text-gray-400 mt-1 pl-1 border-l-2 border-purple-500">å¹³è¡¡å‹é‡å­å…‰æŸï¼Œé©åˆæ‰€æœ‰æˆ°æ³ã€‚</p>
                        </div>
                    </label>

                    <label for="select-cannon" class="block">
                        <input type="radio" id="select-cannon" name="weapon" value="cannon" class="hidden">
                        <div class="select-option group">
                             <div class="flex items-center justify-between">
                                <span class="font-bold text-[#FFD700] neon-text text-lg">ğŸŸ¡ é‡å‹ç«ç ² (CANNON)</span>
                                <span class="text-xs bg-yellow-900 text-yellow-200 px-2 py-1 rounded">HEAVY</span>
                            </div>
                            <p class="text-xs text-gray-400 mt-1 pl-1 border-l-2 border-yellow-500">é«˜èƒ½ç­‰é›¢å­å½ˆï¼Œä¸€ç™¼å…¥é­‚ã€‚</p>
                        </div>
                    </label>
                    
                    <label for="select-rapid" class="block">
                        <input type="radio" id="select-rapid" name="weapon" value="rapid" class="hidden">
                        <div class="select-option group">
                            <div class="flex items-center justify-between">
                                <span class="font-bold text-[#00FFFF] neon-text text-lg">ğŸŸ¢ è„ˆè¡æ©Ÿæ§ (RAPID)</span>
                                <span class="text-xs bg-cyan-900 text-cyan-200 px-2 py-1 rounded">SPEED</span>
                            </div>
                            <p class="text-xs text-gray-400 mt-1 pl-1 border-l-2 border-cyan-500">æ¥µé€Ÿå…‰å­æµï¼Œå½ˆå¹•å£“åˆ¶ã€‚</p>
                        </div>
                    </label>
                </div>

                <!-- æŠ€èƒ½é¸æ“‡å™¨ -->
                <div>
                    <p class="text-lg font-bold mb-3 text-purple-400 neon-text border-b border-gray-700 pb-1">æˆ°è¡“æŠ€èƒ½ [TACTICAL]</p>
                    <label for="select-megabomb" class="block">
                        <input type="radio" id="select-megabomb" name="skill" value="megabomb" class="hidden" checked>
                        <div class="select-option">
                            <span class="font-semibold text-[#A855F7]">ğŸ’£ å·¨å‹ç‚¸å½ˆ (3æ¬¡)</span>
                            <p class="text-xs text-gray-400">å…¨è¢å¹•æ¯€æ»…æ€§æ‰“æ“Šï¼Œæ¸…é™¤æ‰€æœ‰å¨è„…ã€‚</p>
                        </div>
                    </label>
                    <label for="select-shield" class="block">
                        <input type="radio" id="select-shield" name="skill" value="shield" class="hidden">
                        <div class="select-option">
                            <span class="font-semibold text-[#3b82f6]">ğŸ›¡ï¸ æ™‚ç©ºè­·ç›¾ (2æ¬¡)</span>
                            <p class="text-xs text-gray-400">è¶…è¼‰è­·ç›¾ç³»çµ±ï¼Œç„¡æ•µ 3 ç§’ä¸¦åå½ˆå‚·å®³ã€‚</p>
                        </div>
                    </label>
                </div>
            </div>
            
            <!-- ç­‰ç´šå‡ç´šé¸å–® -->
            <div id="upgrade-menu" class="hidden text-left mb-6 space-y-3">
                <p class="text-xl font-bold mb-3 text-lime-400 neon-text animate-pulse">æ ¸å¿ƒå‡ç´š [CORE UPGRADE]:</p>
                <div id="upgrade-options" class="space-y-3">
                    <!-- Upgrades inserted via JS -->
                </div>
            </div>

            <button id="modal-button" class="w-full py-4 text-xl font-bold rounded-lg control-btn tracking-widest uppercase hover:brightness-125">
                [ ENGAGE ]
            </button>
        </div>
    </div>
</div>

<script>
    // --- éŠæˆ²å¸¸æ•¸é…ç½® ---
    const WEAPONS = {
        'blaster': { 
            cooldown: 15, 
            bulletSize: 4, 
            bulletColor: '#d946ef', // Fuchsia-500
            bulletHeightMultiplier: 5, 
            damage: 1.0, 
            speedMultiplier: 1.0,
            trailColor: '#fae8ff' // Light trail
        },
        'cannon': { 
            cooldown: 40, 
            bulletSize: 10, // Bigger
            bulletColor: '#facc15', // Yellow-400
            bulletHeightMultiplier: 2, 
            damage: 3.0, 
            speedMultiplier: 0.6,
            trailColor: '#fef08a'
        },
        'rapid': { 
            cooldown: 5, 
            bulletSize: 3, 
            bulletColor: '#22d3ee', // Cyan-400
            bulletHeightMultiplier: 3, 
            damage: 0.3,
            speedMultiplier: 1.5,
            trailColor: '#cffafe'
        },
    };

    const SKILLS = {
        'megabomb': {
            name: 'å·¨å‹ç‚¸å½ˆ',
            initialCharges: 3,
            color: '#d946ef', 
            effect: function() {
                const canvasCenterX = canvas.width / 2;
                const canvasCenterY = canvas.height / 2;
                
                // å·¨å¤§çš„è¡æ“Šæ³¢
                createShockwave(canvasCenterX, canvasCenterY, '#d946ef', 2000); 
                createShockwave(canvasCenterX, canvasCenterY, '#ffffff', 1500);

                for (let i = 0; i < 100; i++) {
                    createParticle(canvasCenterX, canvasCenterY, SKILLS[gameState.currentSkillId].color, 60);
                }
                
                gameState.enemies.forEach(enemy => {
                    createExplosion(enemy.x, enemy.y, enemy.color, 40);
                    gainXP(CFG.XP_PER_KILL); 
                    gameState.score += CFG.SCORE_PER_KILL; 
                });
                gameState.enemies = []; 

                // æ¸…é™¤ Boss å­å½ˆ
                gameState.bossBullets.forEach(b => {
                     createParticle(b.x, b.y, '#FF3333', 10);
                });
                gameState.bossBullets = [];

                if (gameState.isBossStage && gameState.boss) {
                    const boss = gameState.boss;
                    boss.health -= 50; 
                    boss.flashTime = 10;
                    createExplosion(boss.x, boss.y, '#FFFFFF', 40);
                    if(boss.health <= 0) {
                        killBoss(boss);
                    } else {
                        triggerScreenShake(20);
                    }
                } else {
                    triggerScreenShake(40);
                }
                updateInfoDisplay();
            }
        },
        'shield': {
            name: 'æ™‚ç©ºè­·ç›¾',
            initialCharges: 2,
            color: '#3b82f6',
            effect: function() {
                gameState.isInvulnerable = true;
                gameState.shieldDuration = 180; 
                triggerScreenShake(15);
                // è­·ç›¾å•Ÿå‹•è¦–è¦º
                createShockwave(gameState.player.x, gameState.player.y, '#3b82f6', 500);
            }
        }
    };
    
    const UPGRADES = [
        {
            id: 'damage',
            name: 'ç«åŠ›å¼·åŒ–æ¨¡çµ„',
            description: 'æ­¦å™¨å‚·å®³æ•ˆèƒ½æå‡ 20%',
            icon: 'ğŸ’¥',
            apply: (state) => { state.upgrades.damageMultiplier += 0.2; }
        },
        {
            id: 'firerate',
            name: 'å†·å»ç¸®æ¸›ç³»çµ±',
            description: 'æ­¦å™¨å†·å»æ™‚é–“æ¸›å°‘ 10%',
            icon: 'âš¡',
            apply: (state) => { state.upgrades.fireRateMultiplier *= 0.9; }
        },
        {
            id: 'maxlife',
            name: 'å¥ˆç±³ä¿®å¾©æ ¸å¿ƒ',
            description: 'æœ€å¤§ç”Ÿå‘½ +1 ä¸¦å®Œå…¨ä¿®å¾©',
            icon: 'â¤ï¸',
            apply: (state) => { 
                state.upgrades.maxLivesBonus += 1; 
                state.maxLives = CFG.MAX_LIVES + state.upgrades.maxLivesBonus;
                state.lives = state.maxLives; 
            }
        },
        {
            id: 'skillcharge',
            name: 'æˆ°è¡“å……èƒ½åŒ…',
            description: 'è£œå…… 1 æ¬¡è¶…ç´šæŠ€èƒ½',
            icon: 'ğŸ”‹',
            apply: (state) => { state.skillCharges += 1; updateSkillButton(); }
        },
        {
            id: 'speed',
            name: 'åé‡åŠ›å¼•æ“',
            description: 'ç§»å‹•é€Ÿåº¦æå‡ 15%',
            icon: 'ğŸš€',
            apply: (state) => { state.upgrades.speedMultiplier *= 1.15; }
        }
    ];

    let CFG = {
        BULLET_SPEED: 16,
        ENEMY_BASE_SPEED: 3, // ç¨å¾®å¿«ä¸€é»æ›´åˆºæ¿€
        ENEMY_SIZE: 45, 
        ENEMY_SPAWN_RATE: 70, 
        MAX_LIVES: 3,
        SCORE_PER_KILL: 10,
        MAX_PARTICLES: 400,
        CANVAS_ASPECT_RATIO: 1 / 1.5,
        NUM_STARS: 120,
        MAX_STAR_SPEED: 10,
        
        XP_PER_KILL: 1, 
        BASE_ENEMY_HEALTH: 1,
        ENEMY_HEALTH_PER_LEVEL: 0.5, 
        BASE_XP_TO_LEVEL: 10,
        XP_INCREASE_PER_LEVEL: 5,

        BOSS_SIZE: 120, 
        BOSS_BASE_HEALTH: 50,
        BOSS_HEALTH_PER_LEVEL: 15, 
        BOSS_SPAWN_INTERVAL: 5, 
        BOSS_ATTACK_COOLDOWN: 60, 
        BOSS_BULLET_SPEED: 7,
        BOSS_BULLET_SIZE: 12,
        BOSS_XP_BONUS: 20, 
    };

    // DOM å…ƒç´ 
    const canvas = document.getElementById('gameCanvas');
    let ctx = canvas.getContext('2d'); 
    const infoScore = document.getElementById('score');
    const infoLives = document.getElementById('lives');
    const infoLevel = document.getElementById('level');
    const infoXPBar = document.getElementById('xp-bar');
    const infoXPText = document.getElementById('xp-text');
    const modal = document.getElementById('message-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalMessage = document.getElementById('modal-message');
    const modalButton = document.getElementById('modal-button');
    const startMenu = document.getElementById('start-menu');
    const upgradeMenu = document.getElementById('upgrade-menu');
    const upgradeOptions = document.getElementById('upgrade-options');
    const skillButton = document.getElementById('skill-button');
    const skillNameDisplay = document.getElementById('skill-name');
    const skillCountDisplay = document.getElementById('skill-count');

    // éŠæˆ²ç‹€æ…‹
    let gameState = {
        running: false,
        score: 0,
        maxLives: CFG.MAX_LIVES,
        lives: CFG.MAX_LIVES,
        player: null,
        bullets: [],
        enemies: [],
        particles: [],
        shockwaves: [], // æ–°å¢è¡æ“Šæ³¢
        stars: [], 
        enemySpawnCounter: 0,
        shakeTime: 0,
        targetX: 0,
        isShooting: false, 
        shootCooldown: 0,
        currentWeaponId: 'blaster', 
        currentSkillId: 'megabomb', 
        skillCharges: 0,
        isInvulnerable: false, 
        shieldDuration: 0,
        
        boss: null, 
        isBossStage: false,
        bossBullets: [], 
        
        level: 1,
        xp: 0,
        xpToNextLevel: CFG.BASE_XP_TO_LEVEL,
        isUpgrading: false,
        upgrades: {
            damageMultiplier: 1,
            fireRateMultiplier: 1,
            maxLivesBonus: 0,
            speedMultiplier: 1,
        },
    };

    // --- ç¹ªåœ–èˆ‡ç‰©ä»¶å·¥å»  ---

    function createStar() {
        const z = Math.random(); 
        const speed = 2 + z * CFG.MAX_STAR_SPEED; 
        const size = 0.5 + z * 2; // æ˜Ÿæ˜Ÿå¤§å°å·®ç•°æ›´å¤§
        return {
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: size,
            speed: speed,
            color: z > 0.9 ? '#ffffff' : (z > 0.6 ? '#1effe0' : '#8b5cf6'),
            trail: []
        };
    }
    function drawStar(star) {
        // ç•«æ˜Ÿæ˜Ÿæ‹–å°¾
        ctx.strokeStyle = star.color;
        ctx.lineWidth = star.size * 0.5;
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.moveTo(star.x, star.y);
        ctx.lineTo(star.x, star.y - star.speed * 2); // ç°¡å–®çš„å‚ç›´æ‹–å°¾
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        ctx.fillStyle = star.color;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
    }
    function updateStar(star) {
        star.y += star.speed;
        if (star.y > canvas.height) {
            star.y = 0;
            star.x = Math.random() * canvas.width;
        }
    }

    function drawPlayer(p) {
        const weapon = WEAPONS[gameState.currentWeaponId];
        const weaponColor = weapon ? weapon.bulletColor : '#FFFFFF';

        ctx.save();
        ctx.translate(p.x, p.y);

        // --- æ©Ÿé«”å‚¾æ–œæ•ˆæœ ---
        // è¨ˆç®—å‚¾æ–œè§’åº¦: æ ¹æ“šç›®æ¨™ä½ç½®çš„è·é›¢
        const tiltMax = 0.3; // æœ€å¤§å‚¾æ–œå¼§åº¦
        let tilt = (gameState.targetX - p.x) * 0.005; 
        tilt = Math.max(-tiltMax, Math.min(tiltMax, tilt));
        ctx.rotate(tilt);

        // --- è­·ç›¾æ•ˆæœ ---
        if (gameState.isInvulnerable) {
            const glowRadius = p.width * 1.5;
            const glowOpacity = 0.3 + Math.sin(Date.now() / 50) * 0.2; 
            ctx.fillStyle = `rgba(59, 130, 246, ${glowOpacity})`; 
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 40;
            ctx.beginPath();
            ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // è­·ç›¾ç¶²æ ¼ç´‹è·¯
            ctx.strokeStyle = `rgba(147, 197, 253, ${glowOpacity + 0.2})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, glowRadius * 0.9, 0, Math.PI * 2);
            ctx.stroke();
        }

        // --- å¼•æ“å°¾ç„° (å‹•æ…‹ç²’å­) ---
        // é€™è£¡ä¸ç›´æ¥ç•«ï¼Œè€Œæ˜¯ç”¢ç”Ÿç²’å­
        if (gameState.running && !gameState.isUpgrading) {
            // å·¦å¼•æ“
            if(Math.random() > 0.5) createEngineParticle(p.x - 15, p.y + 25, '#00ffff');
            // å³å¼•æ“
            if(Math.random() > 0.5) createEngineParticle(p.x + 15, p.y + 25, '#00ffff');
        }

        // --- æ©Ÿé«”ç¹ªè£½ ---
        // é™°å½±/å…‰æšˆ
        ctx.shadowColor = weaponColor;
        ctx.shadowBlur = 20; 
        
        // æ©Ÿèº«ä¸»é«” - æ·±è‰²åº•
        ctx.fillStyle = '#0f172a'; 
        ctx.beginPath();
        ctx.moveTo(0, -p.height / 2); 
        ctx.lineTo(p.width / 2, p.height / 2); 
        ctx.lineTo(0, p.height / 3); // å°¾éƒ¨å…§å‡¹
        ctx.lineTo(-p.width / 2, p.height / 2); 
        ctx.closePath();
        ctx.fill();
        
        // æ©Ÿèº«ç·šæ¢ - éœ“è™¹é‚Šæ¡†
        ctx.strokeStyle = weaponColor;
        ctx.lineWidth = 3;
        ctx.lineJoin = 'round';
        ctx.stroke();

        // é§•é§›è‰™
        ctx.fillStyle = '#FFFFFF';
        ctx.shadowBlur = 30; // å¼·çƒˆå…‰æšˆ
        ctx.shadowColor = '#FFFFFF';
        ctx.beginPath();
        ctx.moveTo(0, -p.height/4);
        ctx.lineTo(5, 0);
        ctx.lineTo(0, 5);
        ctx.lineTo(-5, 0);
        ctx.fill();

        // è£é£¾ç¿¼
        ctx.fillStyle = weaponColor;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.moveTo(-p.width/2, p.height/2);
        ctx.lineTo(-p.width/2 - 5, p.height/2 - 10);
        ctx.lineTo(-p.width/2, p.height/2 - 20);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(p.width/2, p.height/2);
        ctx.lineTo(p.width/2 + 5, p.height/2 - 10);
        ctx.lineTo(p.width/2, p.height/2 - 20);
        ctx.fill();
        ctx.globalAlpha = 1.0;

        ctx.shadowBlur = 0; 
        ctx.restore();
    }

    function drawBullet(b) {
        const weapon = WEAPONS[b.weaponId];
        const color = weapon.bulletColor;
        
        ctx.fillStyle = color; 
        ctx.shadowColor = color;
        ctx.shadowBlur = 15; 
        
        // ç•«å­å½ˆ
        const w = b.radius * 2;
        const h = b.radius * weapon.bulletHeightMultiplier * 1.5;
        
        // æ ¸å¿ƒ
        ctx.fillStyle = '#fff';
        ctx.fillRect(b.x - w/4, b.y - h/2, w/2, h);
        
        // å…‰æšˆå¤–æ®¼
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.6;
        ctx.fillRect(b.x - w/2, b.y - h/2 + 5, w, h-5);
        ctx.globalAlpha = 1.0;

        ctx.shadowBlur = 0;
    }

    function drawEnemy(e) {
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.rotate(e.angle); 

        // å—æ“Šé–ƒç™½æ•ˆæœ
        if (e.flashTime > 0) {
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 30;
            const size = e.width * 0.8;
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size, size/2);
            ctx.lineTo(-size, size/2);
            ctx.fill();
            e.flashTime--;
            ctx.restore();
            return; // é–ƒç™½æ™‚ä¸ç•«åŸæœ¬çš„æ¨£å­
        }

        const halfW = e.width / 2;
        const halfH = e.height / 2;
        const primaryColor = e.color; 
        
        // æ•µæ©Ÿå…‰æšˆ
        ctx.shadowColor = primaryColor;
        ctx.shadowBlur = 15;
        
        // æ•µæ©Ÿä¸»é«” - å¹¾ä½•å½¢ç‹€
        ctx.strokeStyle = primaryColor;
        ctx.lineWidth = 3;
        ctx.fillStyle = 'rgba(20, 10, 30, 0.9)'; 

        ctx.beginPath();
        // ç•«ä¸€å€‹æ›´æœ‰ç§‘æŠ€æ„Ÿçš„å½¢ç‹€
        ctx.moveTo(0, halfH); 
        ctx.lineTo(-halfW, -halfH * 0.5);
        ctx.lineTo(0, -halfH);
        ctx.lineTo(halfW, -halfH * 0.5);
        ctx.closePath();
        
        ctx.fill();
        ctx.stroke();
        ctx.shadowBlur = 0; 

        // æ•µæ©Ÿæ ¸å¿ƒ - è„ˆå‹•
        const coreSize = halfW * 0.4;
        const pulse = 0.8 + Math.sin(Date.now() / 100) * 0.2; 
        ctx.fillStyle = primaryColor; 
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(0, 0, coreSize * pulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
        
        // å¼•æ“å™´å°„
        ctx.fillStyle = '#f59e0b'; // Orange engine
        ctx.beginPath();
        ctx.moveTo(-5, -halfH);
        ctx.lineTo(5, -halfH);
        ctx.lineTo(0, -halfH - 10 - Math.random()*5);
        ctx.fill();

        ctx.restore(); 
        
        // ç”Ÿå‘½æ¢ (åªåœ¨å—å‚·æ™‚é¡¯ç¤º)
        if (e.health < e.maxHealth) {
            const hpBarWidth = e.width;
            const hpBarHeight = 3;
            const hpRatio = e.health / e.maxHealth;
            const barX = e.x - hpBarWidth / 2;
            const barY = e.y - e.height / 2 - 15;

            ctx.fillStyle = '#374151'; 
            ctx.fillRect(barX, barY, hpBarWidth, hpBarHeight);
            
            ctx.fillStyle = hpRatio > 0.5 ? '#10b981' : '#ef4444'; 
            ctx.fillRect(barX, barY, hpBarWidth * hpRatio, hpBarHeight);
        }
    }
    
    // --- å¤šé‡é­”ç‹ç¹ªè£½ ---
    function drawBoss(b) {
        ctx.save();
        ctx.translate(b.x, b.y);

        // å—æ“Šé–ƒç™½
        if (b.flashTime > 0) {
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 50;
            ctx.beginPath();
            if (b.bossType === 'titan') {
                ctx.rect(-b.width/2, -b.height/2, b.width, b.height);
            } else if (b.bossType === 'voideye') {
                ctx.moveTo(0, -b.height/2);
                ctx.lineTo(b.width/2, 0);
                ctx.lineTo(0, b.height/2);
                ctx.lineTo(-b.width/2, 0);
            } else {
                ctx.arc(0, 0, b.width/2, 0, Math.PI * 2);
            }
            ctx.fill();
            b.flashTime--;
            ctx.restore();
            drawBossHealth(b);
            return;
        }

        // æ ¹æ“šé¡å‹ç¹ªè£½ä¸åŒå¤–è§€
        if (b.bossType === 'voideye') {
            // --- è™›ç©ºä¹‹çœ¼ (ç´«è‰²ï¼Œè±å½¢/çœ¼ç›) ---
            const pulse = Math.sin(Date.now() / 200) * 5;
            
            // å¤–æ®¼
            ctx.shadowColor = b.color;
            ctx.shadowBlur = 30;
            ctx.strokeStyle = b.color;
            ctx.lineWidth = 4;
            ctx.fillStyle = '#1a051a'; // æ·±ç´«åº•
            
            ctx.beginPath();
            ctx.moveTo(0, -b.height/1.5);
            ctx.lineTo(b.width/1.5, 0);
            ctx.lineTo(0, b.height/1.5);
            ctx.lineTo(-b.width/1.5, 0);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // çœ¼ç›
            ctx.fillStyle = '#e879f9'; // äº®ç²‰ç´«
            ctx.beginPath();
            // è®“ç³å­”è¿½è¹¤ç©å®¶
            const angleToPlayer = Math.atan2(gameState.player.y - b.y, gameState.player.x - b.x);
            const pupilDist = 10;
            const px = Math.cos(angleToPlayer) * pupilDist;
            const py = Math.sin(angleToPlayer) * pupilDist;
            
            ctx.arc(px, py, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤–éƒ¨æ—‹è½‰ç’°
            ctx.rotate(Date.now() / -800);
            ctx.strokeStyle = '#c026d3';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, b.width * 0.7, 0, Math.PI * 2);
            ctx.stroke();

        } else if (b.bossType === 'titan') {
            // --- é‹¼éµæ³°å¦ (é»ƒè‰²ï¼Œæ–¹å½¢é‡è£ç”²) ---
            ctx.shadowColor = b.color;
            ctx.shadowBlur = 20;
            
            // ä¸»é«”
            ctx.fillStyle = '#2a1a05'; // æ·±è¤åº•
            ctx.strokeStyle = b.color;
            ctx.lineWidth = 5;
            ctx.fillRect(-b.width/2, -b.height/2, b.width, b.height);
            ctx.strokeRect(-b.width/2, -b.height/2, b.width, b.height);

            // è£é£¾ç´‹è·¯ (å·¥æ¥­é¢¨)
            ctx.fillStyle = '#f59e0b';
            ctx.fillRect(-b.width/2 + 10, -b.height/2 + 10, 20, 20); // å·¦ä¸Šèºçµ²
            ctx.fillRect(b.width/2 - 30, -b.height/2 + 10, 20, 20); // å³ä¸Šèºçµ²
            ctx.fillRect(-b.width/2 + 10, b.height/2 - 30, 20, 20); // å·¦ä¸‹èºçµ²
            ctx.fillRect(b.width/2 - 30, b.height/2 - 30, 20, 20); // å³ä¸‹èºçµ²
            
            // æ ¸å¿ƒé–‹å£
            const openAmount = (Math.sin(Date.now() / 500) + 1) * 0.5 * 10;
            ctx.fillStyle = '#ff0000'; // æ ¸å¿ƒç´…å…‰
            ctx.fillRect(-20, -10 - openAmount, 40, 20 + openAmount * 2);

        } else {
            // --- æ¯€æ»…è€… (ç´…è‰²ï¼Œåœ“å½¢ï¼ŒåŸç‰ˆ) ---
            const halfW = b.width / 2;
            const primaryColor = b.color; 
            
            ctx.shadowColor = primaryColor;
            ctx.shadowBlur = 30;
            
            // æ—‹è½‰ç’°
            ctx.save();
            ctx.rotate(Date.now() / 1000);
            ctx.strokeStyle = primaryColor;
            ctx.lineWidth = 4;
            ctx.setLineDash([20, 10]); 
            ctx.beginPath();
            ctx.arc(0, 0, halfW, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            // ä¸»é«”
            ctx.fillStyle = '#1a0505';
            ctx.beginPath();
            ctx.arc(0, 0, halfW * 0.8, 0, Math.PI * 2);
            ctx.fill();

            // æ ¸å¿ƒ
            ctx.fillStyle = '#fca5a5';
            ctx.shadowColor = '#fca5a5';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            const eyeOffset = Math.sin(Date.now() / 200) * 10;
            ctx.arc(0, eyeOffset, 15, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
        drawBossHealth(b);
    }

    function drawBossHealth(b) {
        const hpBarWidth = b.width * 1.5;
        const hpBarHeight = 12;
        const hpRatio = b.health / b.maxHealth;
        const barX = b.x - hpBarWidth / 2;
        const barY = b.y - b.height / 2 - 40;

        // é‚Šæ¡†
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, hpBarWidth, hpBarHeight);

        // èƒŒæ™¯
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; 
        ctx.fillRect(barX, barY, hpBarWidth, hpBarHeight);
        
        // è¡€æ¢
        ctx.fillStyle = hpRatio > 0.5 ? '#eab308' : '#ef4444'; 
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 10;
        ctx.fillRect(barX+1, barY+1, (hpBarWidth-2) * hpRatio, hpBarHeight-2);
        ctx.shadowBlur = 0;

        // æ–‡å­—
        ctx.fillStyle = b.color; // ä½¿ç”¨ Boss é¡è‰²
        ctx.font = '900 16px Orbitron';
        ctx.textAlign = 'center';
        ctx.shadowColor = b.color;
        ctx.shadowBlur = 5;
        ctx.fillText(`WARNING: ${b.name} LV.${gameState.level}`, b.x, barY - 10);
        ctx.shadowBlur = 0;
    }
    
    function drawBossBullet(b) {
        ctx.fillStyle = b.color || '#f87171'; 
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 10; 
        
        ctx.beginPath();
        if (b.type === 'laser') {
            // é•·æ¢å½¢å­å½ˆ
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(Math.atan2(b.vy, b.vx));
            ctx.fillRect(-10, -3, 20, 6);
            ctx.restore();
        } else if (b.type === 'heavy') {
            // å¤§åœ“å½ˆ
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
            // æ ¸å¿ƒé»‘é»
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius * 0.6, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // æ™®é€šå½ˆ
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius * 0.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.shadowBlur = 0;
    }

    // --- ç²’å­ç³»çµ±å¼·åŒ– ---
    function createEngineParticle(x, y, color) {
         if (gameState.particles.length >= CFG.MAX_PARTICLES) return;
         gameState.particles.push({
            x, y, 
            size: Math.random() * 3 + 2, 
            color, 
            vx: (Math.random() - 0.5) * 1, 
            vy: Math.random() * 2 + 2, // å‘ä¸‹å™´
            life: 20, 
            gravity: 0,
            type: 'engine',
            draw: function() { 
                const alpha = this.life / 20;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.size, this.size); // æ–¹å½¢ç²’å­æ›´æœ‰æ•¸ä½æ„Ÿ
                ctx.fill();
                ctx.globalAlpha = 1.0;
            },
            update() {
                this.x += this.vx; 
                this.y += this.vy; 
                this.life--;
                this.size *= 0.9; // è®Šå°
            }
        });
    }

    function createParticle(x, y, color, life = 50) {
        return {
            x, y, size: Math.random() * 4 + 2, color, 
            vx: (Math.random() - 0.5) * 10, 
            vy: (Math.random() - 0.5) * 10, 
            life: life, 
            gravity: 0.1,
            type: 'spark',
            draw: function() { 
                const alpha = this.life / life;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            },
            update() {
                this.x += this.vx; 
                this.y += this.vy; 
                this.vy += this.gravity; 
                this.life--;
                this.vx *= 0.95; // é˜»åŠ›
                this.vy *= 0.95;
            }
        };
    }

    function createShockwave(x, y, color, duration = 20) {
        gameState.shockwaves.push({
            x, y, color, duration, maxDuration: duration,
            draw: function() {
                const progress = 1 - (this.duration / this.maxDuration);
                const radius = progress * 100 * (this.maxDuration / 20); // ç¯„åœ
                const alpha = 1 - progress;
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5 * alpha;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            },
            update: function() {
                this.duration--;
            }
        });
    }

    function createExplosion(x, y, color, count = 20) {
        // è¡æ“Šæ³¢
        createShockwave(x, y, color, 30);
        
        // ç²’å­
        for (let i = 0; i < count; i++) { 
            if (gameState.particles.length < CFG.MAX_PARTICLES) {
                gameState.particles.push(createParticle(x, y, color, 40 + Math.random() * 20));
            }
        }
    }

    // --- éŠæˆ²é‚è¼¯ç‰©ä»¶ ---
    
    const PlayerObject = {
        width: 50, height: 60, x: 0, y: 0, 
        init(x, y) { this.x = x; this.y = y; gameState.targetX = x; },
        draw: function() { drawPlayer(this); },
        update() {
            const speed = 12 * gameState.upgrades.speedMultiplier; // åŸºç¤é€Ÿåº¦èª¿æ•´
            const diff = gameState.targetX - this.x;
            
            // å¹³æ»‘ç§»å‹• (Lerp)
            this.x += diff * 0.15 * gameState.upgrades.speedMultiplier;

            if (this.x < this.width / 2) this.x = this.width / 2;
            else if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
        },
        getBounds: function() { 
            return { 
                x: this.x - this.width / 3, 
                y: this.y - this.height / 3, 
                width: this.width * 0.6, 
                height: this.height * 0.6 
            }; 
        }, 
    };
    
    function createBullet(x, y, weaponId) {
        const weapon = WEAPONS[weaponId];
        // éš¨æ©Ÿä¸€é»é»å·¦å³åç§»ï¼Œå¢åŠ è‡ªç„¶æ„Ÿ
        const offsetX = (Math.random() - 0.5) * 4;
        return {
            x: x + offsetX, y: y - PlayerObject.height / 2, radius: weapon.bulletSize, weaponId: weaponId,
            damage: weapon.damage * gameState.upgrades.damageMultiplier, 
            speed: CFG.BULLET_SPEED * weapon.speedMultiplier, 
            draw: function() { drawBullet(this); },
            update() { 
                this.y -= this.speed; 
                // å­å½ˆæ‹–å°¾ç²’å­
                if (Math.random() > 0.7) {
                    const p = createParticle(this.x, this.y + 10, weapon.trailColor, 10);
                    p.vx = 0; p.vy = 2; p.size = 2;
                    gameState.particles.push(p);
                }
            },
            getBounds() { return { x: this.x - this.radius, y: this.y - this.radius, width: this.radius*2, height: this.radius*2 }; }
        };
    }

    function createEnemy(x, y) {
        const colors = ['#f472b6', '#fbbf24', '#22d3ee']; // Pink, Amber, Cyan
        const baseHealth = CFG.BASE_ENEMY_HEALTH + (gameState.level - 1) * CFG.ENEMY_HEALTH_PER_LEVEL;
        const health = Math.ceil(baseHealth); 
        
        return {
            x: x, y: y, width: CFG.ENEMY_SIZE, height: CFG.ENEMY_SIZE, color: colors[Math.floor(Math.random() * colors.length)],
            angle: 0,
            rotationSpeed: (Math.random() - 0.5) * 0.1,
            health: health,
            maxHealth: health,
            flashTime: 0, // å—æ“Šé–ƒç™½è¨ˆæ™‚å™¨
            draw: function() { drawEnemy(this); },
            update() { 
                this.y += CFG.ENEMY_BASE_SPEED; 
                this.angle += this.rotationSpeed;
            },
            getBounds() { return { x: this.x - this.width / 2, y: this.y - this.height / 2, width: this.width, height: this.height }; }
        };
    }
    
    // --- æ–°ï¼šå¤šé‡ Boss ç”Ÿæˆå™¨ ---
    function createBoss(level) {
        const bossLevelMultiplier = Math.floor((level - 1) / CFG.BOSS_SPAWN_INTERVAL) + 1;
        const baseHealth = CFG.BOSS_BASE_HEALTH + bossLevelMultiplier * CFG.BOSS_HEALTH_PER_LEVEL;
        
        // éš¨æ©Ÿé¸æ“‡ä¸€ç¨® Boss
        const types = ['overlord', 'voideye', 'titan'];
        const type = types[Math.floor(Math.random() * types.length)];
        // const type = 'titan'; // Debugç”¨

        let boss = {
            x: canvas.width / 2, y: -CFG.BOSS_SIZE, 
            width: CFG.BOSS_SIZE, height: CFG.BOSS_SIZE * 0.8,
            health: baseHealth,
            maxHealth: baseHealth,
            color: '#FF0000',
            speedX: 3,
            isMovingRight: true,
            attackCooldown: CFG.BOSS_ATTACK_COOLDOWN,
            targetY: CFG.BOSS_SIZE * 1.5, 
            flashTime: 0,
            bossType: type,
            name: 'UNKNOWN',
            
            draw: function() { drawBoss(this); },
            update: function() { updateBoss(this); }, // é€šç”¨æ›´æ–°é‚è¼¯
            getBounds: function() { return { x: this.x - this.width / 2, y: this.y - this.height / 2, width: this.width, height: this.height }; }
        };

        // æ ¹æ“šé¡å‹èª¿æ•´å±¬æ€§
        if (type === 'voideye') {
            boss.name = 'VOID EYE';
            boss.color = '#a855f7'; // Purple
            boss.maxHealth *= 0.8; // è¡€å°‘
            boss.health = boss.maxHealth;
            boss.width *= 0.9;
            boss.attackCooldown = 40; // æ”»é€Ÿå¿«
        } else if (type === 'titan') {
            boss.name = 'IRON TITAN';
            boss.color = '#f59e0b'; // Amber
            boss.maxHealth *= 1.5; // è¡€åš
            boss.health = boss.maxHealth;
            boss.width *= 1.2;
            boss.speedX = 1; // ç§»å‹•æ…¢
            boss.attackCooldown = 80; // æ”»é€Ÿæ…¢
        } else {
            boss.name = 'OVERLORD';
            boss.color = '#ef4444'; // Red
        }
        
        return boss;
    }

    // --- æ–°ï¼šå¤šé‡ Boss æ›´æ–°é‚è¼¯ ---
    function updateBoss(boss) {
        // 1. ç§»å‹•é€²å ´èˆ‡å·¦å³ç§»å‹•
        if (boss.y < boss.targetY) {
            boss.y += 2;
        } else {
            if (boss.isMovingRight) {
                boss.x += boss.speedX;
                if (boss.x > canvas.width - boss.width/2 - 20) boss.isMovingRight = false;
            } else {
                boss.x -= boss.speedX;
                if (boss.x < boss.width/2 + 20) boss.isMovingRight = true;
            }
        }
        
        // 2. æ”»æ“Šé‚è¼¯
        boss.attackCooldown--;
        if (boss.attackCooldown <= 0) {
            
            if (boss.bossType === 'voideye') {
                // --- è™›ç©ºä¹‹çœ¼ï¼šè¿½è¹¤ç©å®¶çš„å¿«é€Ÿé›·å°„ ---
                const angle = Math.atan2(gameState.player.y - boss.y, gameState.player.x - boss.x);
                const speed = 9;
                gameState.bossBullets.push(createBossBullet(boss.x, boss.y, Math.cos(angle) * speed, Math.sin(angle) * speed, 'laser', '#d8b4fe'));
                boss.attackCooldown = 25; // é€£å°„é–“éš”çŸ­
                triggerScreenShake(2);

            } else if (boss.bossType === 'titan') {
                // --- é‹¼éµæ³°å¦ï¼šå½ˆå¹•é›¨ ---
                for (let i = -3; i <= 3; i++) {
                    gameState.bossBullets.push(createBossBullet(boss.x + i * 30, boss.y + boss.height/2, i * 0.5, 5, 'heavy', '#fbbf24'));
                }
                boss.attackCooldown = 100; // å†·å»ä¹…
                triggerScreenShake(15); // å¼·çƒˆéœ‡å‹•

            } else {
                // --- æ¯€æ»…è€…ï¼šä¸‰å‘æ•£å½ˆ (åŸç‰ˆ) ---
                for(let i=-2; i<=2; i++) {
                     gameState.bossBullets.push(createBossBullet(boss.x, boss.y + boss.height/2, i * 2, 6, 'normal', '#f87171'));
                }
                boss.attackCooldown = Math.max(30, CFG.BOSS_ATTACK_COOLDOWN - gameState.level);
                triggerScreenShake(8);
            }
        }
    }

    function createBossBullet(x, y, vx, vy, type = 'normal', color = '#f87171') {
        let radius = CFG.BOSS_BULLET_SIZE;
        if (type === 'heavy') radius = 15;
        if (type === 'laser') radius = 6;
        
        return {
            x: x, y: y, radius: radius, 
            damage: 1, 
            vx: vx, vy: vy,
            type: type,
            color: color,
            draw: function() { drawBossBullet(this); },
            update() { 
                this.x += this.vx;
                this.y += this.vy; 
            },
            getBounds() { return { x: this.x - this.radius, y: this.y - this.radius, width: this.radius*2, height: this.radius*2 }; }
        };
    }

    // --- æ ¸å¿ƒéŠæˆ²ç³»çµ± ---

    function initGame() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        gameState.stars = [];
        for(let i=0; i<CFG.NUM_STARS; i++) {
            gameState.stars.push(createStar());
        }

        canvas.addEventListener('mousemove', handleInputMove);
        canvas.addEventListener('touchmove', handleInputMove, {passive: false});
        
        canvas.addEventListener('mousedown', () => { gameState.isShooting = true; });
        canvas.addEventListener('mouseup', () => { gameState.isShooting = false; });
        canvas.addEventListener('touchstart', (e) => { 
            gameState.isShooting = true; 
            handleInputMove(e); 
        }, {passive: false});
        canvas.addEventListener('touchend', () => { gameState.isShooting = false; });

        skillButton.addEventListener('click', activateSkill);
        
        modalButton.addEventListener('click', () => {
            if (gameState.isUpgrading) {
            } else if (!gameState.running) {
                startGame();
            }
        });

        showStartMenu();
    }

    function resizeCanvas() {
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        if(gameState.player) {
            gameState.player.y = canvas.height - 100;
        }
    }

    function handleInputMove(e) {
        e.preventDefault(); 
        const rect = canvas.getBoundingClientRect();
        let clientX = e.clientX;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
        }
        
        let x = clientX - rect.left;
        x = Math.max(0, Math.min(canvas.width, x));
        
        gameState.targetX = x;
    }

    function startGame() {
        const selectedWeapon = document.querySelector('input[name="weapon"]:checked').value;
        const selectedSkill = document.querySelector('input[name="skill"]:checked').value;
        
        gameState.currentWeaponId = selectedWeapon;
        gameState.currentSkillId = selectedSkill;
        gameState.skillCharges = SKILLS[selectedSkill].initialCharges;
        
        gameState.score = 0;
        gameState.level = 1;
        gameState.lives = CFG.MAX_LIVES;
        gameState.maxLives = CFG.MAX_LIVES;
        gameState.xp = 0;
        gameState.xpToNextLevel = CFG.BASE_XP_TO_LEVEL;
        gameState.enemies = [];
        gameState.bullets = [];
        gameState.bossBullets = [];
        gameState.particles = [];
        gameState.shockwaves = [];
        gameState.boss = null;
        gameState.isBossStage = false;
        gameState.running = true;
        gameState.isUpgrading = false;
        
        gameState.upgrades = {
            damageMultiplier: 1,
            fireRateMultiplier: 1,
            maxLivesBonus: 0,
            speedMultiplier: 1,
        };

        PlayerObject.init(canvas.width / 2, canvas.height - 100);
        gameState.player = PlayerObject;

        modal.classList.add('hidden');
        updateInfoDisplay();
        updateSkillButton();

        requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        gameState.running = false;
        showModal('SYSTEM FAILURE', `FINAL SCORE: <span class="text-white">${gameState.score}</span><br>MAX LEVEL: <span class="text-yellow-400">${gameState.level}</span>`, true);
    }

    function gameLoop() {
        if (!gameState.running) return;
        if (gameState.isUpgrading) {
            requestAnimationFrame(gameLoop);
            return;
        }

        // åŠé€æ˜é»‘è‰²é®ç½©ï¼Œè£½é€ å‹•æ…‹æ¨¡ç³Š (Motion Blur) æ•ˆæœ
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        if (gameState.shakeTime > 0) {
            const intensity = gameState.shakeTime * 1.5; // éœ‡å‹•åŠ å¼·
            const dx = (Math.random() - 0.5) * intensity;
            const dy = (Math.random() - 0.5) * intensity;
            ctx.translate(dx, dy);
            gameState.shakeTime--;
        }

        gameState.stars.forEach(s => { updateStar(s); drawStar(s); });

        // è¡æ“Šæ³¢ (æœ€åº•å±¤)
        gameState.shockwaves = gameState.shockwaves.filter(s => s.duration > 0);
        gameState.shockwaves.forEach(s => { s.update(); s.draw(); });

        gameState.player.update();
        gameState.player.draw();
        
        if (gameState.isShooting) {
            if (gameState.shootCooldown <= 0) {
                const weapon = WEAPONS[gameState.currentWeaponId];
                gameState.bullets.push(createBullet(gameState.player.x, gameState.player.y, gameState.currentWeaponId));
                gameState.shootCooldown = weapon.cooldown * gameState.upgrades.fireRateMultiplier;
                // å°„æ“Šæ™‚è¼•å¾®å¾ŒååŠ›
                gameState.player.y += 2;
                if(gameState.player.y > canvas.height - 50) gameState.player.y = canvas.height - 50;
            } else {
                // æ¢å¾©ä½ç½®
                 gameState.player.y += (canvas.height - 100 - gameState.player.y) * 0.1;
            }
        } else {
             gameState.player.y += (canvas.height - 100 - gameState.player.y) * 0.1;
        }
        if (gameState.shootCooldown > 0) gameState.shootCooldown--;
        
        if (gameState.isInvulnerable) {
            gameState.shieldDuration--;
            if (gameState.shieldDuration <= 0) gameState.isInvulnerable = false;
        }

        gameState.bullets = gameState.bullets.filter(b => b.y > -50);
        gameState.bullets.forEach(b => { b.update(); b.draw(); });

        if (!gameState.isBossStage) {
            if (gameState.enemySpawnCounter <= 0) {
                const x = Math.random() * (canvas.width - CFG.ENEMY_SIZE) + CFG.ENEMY_SIZE/2;
                gameState.enemies.push(createEnemy(x, -CFG.ENEMY_SIZE));
                gameState.enemySpawnCounter = Math.max(15, CFG.ENEMY_SPAWN_RATE - gameState.level * 2);
            } else {
                gameState.enemySpawnCounter--;
            }
        } else if (!gameState.boss) {
            gameState.boss = createBoss(gameState.level);
        }

        gameState.enemies = gameState.enemies.filter(e => e.y < canvas.height + 100 && e.health > 0);
        gameState.enemies.forEach(e => { e.update(); e.draw(); });

        if (gameState.boss) {
            gameState.boss.update(); // ä½¿ç”¨å°è±¡è‡ªå·±çš„æ›´æ–°æ–¹æ³•
            gameState.boss.draw();
        }
        
        gameState.bossBullets = gameState.bossBullets.filter(b => b.y < canvas.height + 50 && b.x > -50 && b.x < canvas.width + 50);
        gameState.bossBullets.forEach(b => { b.update(); b.draw(); });

        gameState.particles = gameState.particles.filter(p => p.life > 0);
        gameState.particles.forEach(p => { p.update(); p.draw(); });

        checkCollisions();
        
        if (!gameState.isBossStage && gameState.level % CFG.BOSS_SPAWN_INTERVAL === 0 && gameState.enemies.length === 0) {
            gameState.isBossStage = true;
            triggerScreenShake(30);
            createShockwave(canvas.width/2, canvas.height/2, '#ff0000', 60);
        }

        ctx.restore();
        requestAnimationFrame(gameLoop);
    }

    function killBoss(boss) {
        createExplosion(boss.x, boss.y, boss.color, 100);
        createShockwave(boss.x, boss.y, '#ffffff', 50);
        createShockwave(boss.x, boss.y, boss.color, 80);
        
        triggerScreenShake(60);
        gameState.score += CFG.SCORE_PER_KILL * 50;
        gainXP(CFG.BOSS_XP_BONUS);
        
        // --- NEW: Boss Reward (æ“Šæ•— Boss çå‹µ) ---
        // æ¢å¾© 1 é»ç”Ÿå‘½ (å¦‚æœæœªæ»¿)
        if (gameState.lives < gameState.maxLives) {
            gameState.lives++;
            // ç¶ è‰²æ²»ç™‚ç‰¹æ•ˆ
            createParticle(gameState.player.x, gameState.player.y, '#22c55e', 30);
            createShockwave(gameState.player.x, gameState.player.y, '#22c55e', 40);
        }
        
        // å¢åŠ  1 å€‹æŠ€èƒ½å……èƒ½ (çœŸçš„åŠ æŠ€èƒ½!)
        gameState.skillCharges++;
        updateSkillButton();
        // ç´«è‰²æŠ€èƒ½ç‰¹æ•ˆ
        createParticle(gameState.player.x, gameState.player.y, '#a855f7', 30);
        createShockwave(gameState.player.x, gameState.player.y, '#a855f7', 40);
        // ----------------------------------------
        
        gameState.boss = null;
        gameState.isBossStage = false;
        gameState.bossBullets = [];
        updateInfoDisplay();
    }

    function checkCollisions() {
        const playerBounds = gameState.player.getBounds();

        gameState.bullets.forEach(bullet => {
            const bBounds = bullet.getBounds();
            
            for (let enemy of gameState.enemies) {
                if (rectIntersect(bBounds, enemy.getBounds())) {
                    enemy.health -= bullet.damage;
                    enemy.flashTime = 3; // å—æ“Šé–ƒç™½ 3 frames
                    bullet.y = -100; 
                    
                    // æ“Šä¸­ç²’å­
                    for(let i=0; i<3; i++) {
                         gameState.particles.push(createParticle(bullet.x, bullet.y, '#fff', 10));
                    }
                    
                    if (enemy.health <= 0) {
                        createExplosion(enemy.x, enemy.y, enemy.color, 15);
                        gameState.score += CFG.SCORE_PER_KILL;
                        gainXP(CFG.XP_PER_KILL);
                        triggerScreenShake(3); // å°éœ‡å‹•
                    }
                    break;
                }
            }
            
            if (gameState.boss && bullet.y > 0) {
                if (rectIntersect(bBounds, gameState.boss.getBounds())) {
                    gameState.boss.health -= bullet.damage;
                    gameState.boss.flashTime = 2;
                    bullet.y = -100;
                    for(let i=0; i<3; i++) {
                         gameState.particles.push(createParticle(bullet.x, bullet.y, '#fff', 10));
                    }
                }
            }
        });

        if (gameState.isInvulnerable) return; 

        for (let enemy of gameState.enemies) {
            if (rectIntersect(playerBounds, enemy.getBounds())) {
                enemy.health = 0; 
                createExplosion(enemy.x, enemy.y, enemy.color, 20);
                takeDamage();
            }
        }
        
        if (gameState.boss && rectIntersect(playerBounds, gameState.boss.getBounds())) {
            takeDamage();
            triggerScreenShake(20);
        }
        
        for (let b of gameState.bossBullets) {
            if (rectIntersect(playerBounds, b.getBounds())) {
                b.y = canvas.height + 200; 
                takeDamage();
            }
        }
    }

    function rectIntersect(r1, r2) {
        return !(r2.x > r1.x + r1.width || 
                 r2.x + r2.width < r1.x || 
                 r2.y > r1.y + r1.height || 
                 r2.y + r2.height < r1.y);
    }

    function takeDamage() {
        triggerScreenShake(30);
        createExplosion(gameState.player.x, gameState.player.y, '#FF0000', 30);
        createShockwave(gameState.player.x, gameState.player.y, '#ff0000', 20);
        gameState.lives--;
        updateInfoDisplay();
        
        if (gameState.lives <= 0) {
            gameOver();
        } else {
            gameState.isInvulnerable = true;
            gameState.shieldDuration = 90; // 1.5ç§’ç„¡æ•µ
        }
    }

    function triggerScreenShake(amount) {
        gameState.shakeTime = amount;
    }

    // --- XP èˆ‡ å‡ç´šç³»çµ± ---

    function gainXP(amount) {
        gameState.xp += amount;
        if (gameState.xp >= gameState.xpToNextLevel) {
            levelUp();
        }
        updateInfoDisplay();
    }

    function levelUp() {
        gameState.level++;
        gameState.xp -= gameState.xpToNextLevel;
        gameState.xpToNextLevel = Math.floor(gameState.xpToNextLevel + CFG.XP_INCREASE_PER_LEVEL);
        
        gameState.isUpgrading = true;
        showUpgradeMenu();
    }

    function showUpgradeMenu() {
        modalTitle.innerText = `LEVEL UP! (LV.${gameState.level})`;
        modalTitle.className = "text-4xl font-extrabold mb-4 text-lime-400 neon-text italic";
        modalMessage.innerText = ">> SELECT UPGRADE MODULE <<";
        
        startMenu.classList.add('hidden');
        upgradeMenu.classList.remove('hidden');
        modalButton.classList.add('hidden'); 
        
        upgradeOptions.innerHTML = '';
        
        const options = [];
        while(options.length < 3) {
            const rand = UPGRADES[Math.floor(Math.random() * UPGRADES.length)];
            if (!options.includes(rand)) options.push(rand);
        }

        options.forEach(opt => {
            const el = document.createElement('div');
            el.className = 'upgrade-card group';
            el.innerHTML = `
                <div class="text-4xl group-hover:scale-110 transition-transform duration-200">${opt.icon}</div>
                <div class="text-left">
                    <div class="font-bold text-lime-400 text-lg group-hover:text-lime-300 transition-colors">${opt.name}</div>
                    <div class="text-sm text-gray-400 group-hover:text-gray-300 transition-colors">${opt.description}</div>
                </div>
            `;
            el.onclick = () => selectUpgrade(opt);
            upgradeOptions.appendChild(el);
        });

        modal.classList.remove('hidden');
    }

    function selectUpgrade(upgrade) {
        upgrade.apply(gameState);
        gameState.isUpgrading = false;
        modal.classList.add('hidden');
        
        createShockwave(canvas.width/2, canvas.height/2, '#84cc16', 40); // å‡ç´šæ™‚çš„ç¶ è‰²æ³¢ç´‹
        
        updateInfoDisplay();
    }

    // --- ä»‹é¢æ›´æ–° ---

    function updateInfoDisplay() {
        infoScore.innerText = gameState.score;
        infoLevel.innerText = gameState.level;
        infoLives.innerText = gameState.lives + '/' + gameState.maxLives;
        
        const xpPercent = (gameState.xp / gameState.xpToNextLevel) * 100;
        infoXPBar.style.width = `${xpPercent}%`;
        infoXPText.innerText = `${gameState.xp}/${gameState.xpToNextLevel} XP`;
    }

    function updateSkillButton() {
        const skill = SKILLS[gameState.currentSkillId];
        skillNameDisplay.innerText = skill.name;
        skillCountDisplay.innerText = gameState.skillCharges;
        
        skillButton.disabled = gameState.skillCharges <= 0;
        
        if (gameState.currentSkillId === 'shield') {
            skillButton.style.background = 'linear-gradient(145deg, #3b82f6, #2563eb)';
            skillButton.style.boxShadow = '0 0 25px rgba(59, 130, 246, 0.9)';
        } else {
            skillButton.style.background = 'linear-gradient(145deg, #a855f7, #9333ea)';
            skillButton.style.boxShadow = '0 0 25px rgba(168, 85, 247, 0.9)';
        }
    }

    function activateSkill() {
        if (gameState.skillCharges > 0 && gameState.running && !gameState.isUpgrading) {
            SKILLS[gameState.currentSkillId].effect();
            gameState.skillCharges--;
            updateSkillButton();
        }
    }

    function showStartMenu() {
        modalTitle.innerText = "æ˜Ÿéš›ç¥æ§æ‰‹ V2.0";
        modalTitle.className = "text-4xl font-extrabold mb-4 neon-title italic";
        modalMessage.innerText = "PILOT, CHOOSE YOUR LOADOUT";
        
        startMenu.classList.remove('hidden');
        upgradeMenu.classList.add('hidden');
        modalButton.classList.remove('hidden');
        modalButton.innerText = "[ ENGAGE ]";
        modal.classList.remove('hidden');
    }

    function showModal(title, msg, isEnd = false) {
        modalTitle.innerText = title;
        modalTitle.className = "text-4xl font-extrabold mb-4 " + (isEnd ? "text-red-500" : "neon-text-purple") + " italic";
        modalMessage.innerHTML = msg;
        
        startMenu.classList.add('hidden'); 
        if(isEnd) startMenu.classList.remove('hidden'); 

        upgradeMenu.classList.add('hidden');
        modalButton.classList.remove('hidden');
        modalButton.innerText = isEnd ? "RESTART MISSION" : "CONFIRM";
        
        modal.classList.remove('hidden');
    }

    // --- å•Ÿå‹• ---
    window.onload = initGame;

</script>
</body>
</html>
