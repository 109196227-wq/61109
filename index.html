<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ˜Ÿéš›ç¥æ§æ‰‹ - å‹•æ…‹é›£åº¦èˆ‡å‡ç´š</title>
    
    <!-- è¼‰å…¥ Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        body {
            font-family: 'Orbitron', sans-serif;
            background: radial-gradient(circle at center, #0a011a 0%, #000000 100%);
            color: #e5e7eb;
            margin: 0;
            /* é—œéµè®Šæ›´ï¼šç§»é™¤å›ºå®šå°ºå¯¸å’Œéš±è—æº¢å‡º */
            min-height: 100vh; /* ç¢ºä¿ä½”æ»¿è‡³å°‘ä¸€å± */
            display: flex;
            justify-content: center; /* ä¿æŒæ°´å¹³ç½®ä¸­ */
            align-items: flex-start; /* è®“å…§å®¹å¾é ‚éƒ¨é–‹å§‹æµå‹• (ä¿®å¾©ç§»å‹•è¨­å‚™åº•éƒ¨è¢«è£åˆ‡çš„å•é¡Œ) */
            padding: 0; 
            /* REMOVED: overflow: hidden; */
            user-select: none; 
            padding-top: 1rem; /* å¢åŠ é ‚éƒ¨é–“è· */
            padding-bottom: 1rem; /* å¢åŠ åº•éƒ¨é–“è· */
        }
        #game-container {
            width: 100%;
            max-width: 600px; /* é™åˆ¶æœ€å¤§å¯¬åº¦ï¼Œæ”¹å–„æ¡Œé¢é¡¯ç¤º */
            /* ç§»é™¤ height: 100%; è®“å®ƒè‡ªç„¶æµå‹• */
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: transparent; 
            padding: 0 1rem; /* èª¿æ•´ç‚ºåªåœ¨å·¦å³æœ‰ paddingï¼Œä¸Šä¸‹é  body çš„ padding */
            border: 2px solid #14b8a61a;
            box-shadow: 0 0 50px rgba(20, 184, 166, 0.4); 
            min-height: 98vh; /* è®“å®ƒç›¡é‡è²¼åˆè¢å¹•ï¼Œä½†å…è¨±è¼•å¾®æº¢å‡º */
        }

        #gameCanvas {
            border: 4px solid #14b8a6; 
            background-color: #000000;
            box-shadow: 0 0 40px rgba(20, 184, 166, 0.9);
            border-radius: 0.5rem; 
            transition: transform 0.05s; 
            touch-action: none; 
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="14" fill="none" stroke="%2314b8a6" stroke-width="2"/><line x1="16" y1="2" x2="16" y2="30" stroke="%2314b8a6" stroke-width="2"/><line x1="2" y1="16" x2="30" y2="16" stroke="%2314b8a6" stroke-width="2"/></svg>'), crosshair;
        }
        .neon-text {
            text-shadow: 0 0 8px #14b8a6, 0 0 15px #14b8a6, 0 0 20px #06b6d4;
        }
        .control-btn {
            background: linear-gradient(145deg, #14b8a6, #0d9488);
            color: #000;
            font-weight: 900;
            border: none;
            box-shadow: 0 4px 20px rgba(20, 184, 166, 0.6), 0 0 10px rgba(255, 255, 255, 0.3) inset;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .control-btn:hover:not([disabled]) {
            transform: scale(1.05);
            background: linear-gradient(145deg, #0d9488, #14b8a6);
            box-shadow: 0 6px 25px rgba(20, 184, 166, 0.9);
        }
        #game-info {
            background-color: #0d011f80;
            border: 1px solid #14b8a650;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px #06b6d450 inset;
        }
        .select-option {
            border: 2px solid #374151;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            transition: all 0.2s;
            cursor: pointer;
            background-color: #0a011a80; 
            backdrop-filter: blur(3px);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        .select-option:hover {
             background-color: #1f293780;
        }
        input[type="radio"]:checked + .select-option,
        .upgrade-card:hover { /* å‡ç´šå¡ç‰‡æ¨£å¼ */
             border-color: #ff33ff; 
             box-shadow: 0 0 15px rgba(255, 51, 255, 0.6);
             background-color: #5b21b633;
        }
        input[type="radio"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }
        #skill-button:not([disabled]) {
            background: linear-gradient(145deg, #a855f7, #9333ea);
            box-shadow: 0 0 25px rgba(168, 85, 247, 0.9);
        }
        #skill-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            background: #4b5563;
            box-shadow: none;
        }
        #message-modal > div {
            background-color: #0d011f;
            border: 4px solid #ff33ff;
            box-shadow: 0 0 30px rgba(255, 51, 255, 0.8);
            max-width: 90%; 
        }
        #modal-title {
            color: #ff33ff;
            text-shadow: 0 0 10px #ff33ff;
        }
        .upgrade-card {
            background-color: #111827;
            border: 2px solid #374151;
            padding: 1rem;
            border-radius: 0.75rem;
            transition: all 0.2s;
            cursor: pointer;
        }
    </style>
</head>
<body class="p-0">

<div id="game-container" class="bg-[#1a1a2e]">
    <h1 class="text-4xl font-extrabold mt-4 mb-2 text-[#14b8a6] neon-text sm:text-5xl">ã€Šæ˜Ÿéš›ç¥æ§æ‰‹ã€‹</h1>
    <!-- æ›´æ–°æ“ä½œæç¤ºç‚ºæ‰‹æ©Ÿè§¸æ§æ¨¡å¼ -->
    <p class="text-sm text-gray-400 mb-2 font-mono">(åœ¨ç•«é¢ä¸Š**æ‹–æ›³**ç§»å‹•ä¸¦**é•·æŒ‰**ç™¼å°„é›·å°„)</p>

    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="gameCanvas" class="flex-grow-0 flex-shrink-0"></canvas>

    <!-- ç‹€æ…‹è³‡è¨Šé¡¯ç¤º (åˆ†æ•¸, ç­‰ç´š, ç”Ÿå‘½) -->
    <div id="game-info" class="flex justify-between w-full max-w-lg mt-3 mb-1 text-2xl font-mono px-4">
        <span class="text-cyan-400">åˆ†æ•¸: <span id="score">0</span></span>
        <span class="text-yellow-400">ç­‰ç´š: <span id="level">1</span></span>
        <span class="text-red-500">ç”Ÿå‘½: <span id="lives">3</span></span>
    </div>

    <!-- ç¶“é©—å€¼æ¢ -->
    <div class="w-full max-w-lg px-4 mb-2">
        <div class="h-2 bg-gray-700 rounded-full">
            <div id="xp-bar" class="h-full rounded-full transition-all duration-300" style="width: 0%; background-color: #34d399;"></div>
        </div>
        <div id="xp-text" class="text-xs text-gray-400 text-right mt-1 font-mono">0/5 XP</div>
    </div>

    <!-- æŠ€èƒ½æŒ‰éˆ• -->
    <div class="w-full max-w-lg flex justify-center pb-4 px-4">
        <button id="skill-button" class="w-full py-3 text-xl font-bold rounded-lg transition duration-150" disabled>
            âš¡ <span id="skill-name">å·¨å‹ç‚¸å½ˆ</span> (<span id="skill-count">3</span>)
        </button>
    </div>
    
    <!-- éŠæˆ²çµæŸ/é–‹å§‹/å‡ç´š è¨Šæ¯æ¨¡çµ„ -->
    <div id="message-modal" class="fixed inset-0 bg-black bg-opacity-90 flex justify-center items-center z-50 hidden">
        <div class="bg-gray-900 p-8 rounded-2xl text-center w-full max-w-md">
            <h2 id="modal-title" class="text-4xl font-extrabold mb-4 neon-text"></h2>
            <p id="modal-message" class="text-lg mb-4 text-gray-300 font-mono"></p>
            
            <!-- å•Ÿå‹•/éŠæˆ²çµæŸ é¸å–® -->
            <div id="start-menu" class="text-left mb-6 space-y-4">
                
                <!-- æ­¦å™¨é¸æ“‡å™¨ -->
                <div>
                    <p class="text-xl font-bold mb-3 text-yellow-400">é¸æ“‡ä¸»æ­¦å™¨ [WEAPON]:</p>
                    <label for="select-blaster" class="block">
                        <input type="radio" id="select-blaster" name="weapon" value="blaster" checked>
                        <div class="select-option">
                            <span class="font-semibold text-[#ff33ff]">æ¨™æº–é›·å°„ (BLASTER)</span>
                            <p class="text-sm text-gray-400">âœ… å¹³è¡¡å‹ï¼šä¸­ç­‰å°„é€Ÿï¼Œç´«è‰²å…‰æŸã€‚</p>
                        </div>
                    </label>
                    <label for="select-cannon" class="block">
                        <input type="radio" id="select-cannon" name="weapon" value="cannon">
                        <div class="select-option">
                            <span class="font-semibold text-[#FFFF00]">é‡å‹ç«ç ² (CANNON)</span>
                            <p class="text-sm text-gray-400">ğŸ’¥ å¼·åŠ›å‹ï¼šå°„é€Ÿæ…¢ï¼Œ**é»ƒè‰²èƒ½é‡å½ˆ**ï¼ˆå¤§ç¯„åœï¼‰ã€‚</p>
                        </div>
                    </label>
                    <label for="select-rapid" class="block">
                        <input type="radio" id="select-rapid" name="weapon" value="rapid">
                        <div class="select-option">
                            <span class="font-semibold text-[#00FFFF]">è„ˆè¡æ©Ÿæ§ (RAPID)</span>
                            <p class="text-sm text-gray-400">âš¡ é€Ÿåº¦å‹ï¼š**æ¥µé«˜å°„é€Ÿ**ï¼Œé’è‰²å…‰é»ï¼ˆå°ç¯„åœï¼‰ã€‚</p>
                        </div>
                    </label>
                </div>

                <!-- æŠ€èƒ½é¸æ“‡å™¨ -->
                <div>
                    <p class="text-xl font-bold mb-3 text-purple-400">é¸æ“‡è¶…ç´šæŠ€èƒ½ [SKILL]:</p>
                    <label for="select-megabomb" class="block">
                        <input type="radio" id="select-megabomb" name="skill" value="megabomb" checked>
                        <div class="select-option">
                            <span class="font-semibold text-[#A855F7]">å·¨å‹ç‚¸å½ˆ (MEGA BOMB)</span>
                            <p class="text-sm text-gray-400">ğŸ’£ é–‹å±€ **3 æ¬¡**ã€‚ç«‹å³æ¸…ç©ºè¢å¹•ä¸Šæ‰€æœ‰å¨è„…ï¼</p>
                        </div>
                    </label>
                    <label for="select-shield" class="block">
                        <input type="radio" id="select-shield" name="skill" value="shield">
                        <div class="select-option">
                            <span class="font-semibold text-[#3b82f6]">æ™‚ç©ºè­·ç›¾ (SHIELD)</span>
                            <p class="text-sm text-gray-400">ğŸ›¡ï¸ é–‹å±€ **2 æ¬¡**ã€‚å•Ÿå‹•å¾Œç„¡æ•µ 3 ç§’ã€‚</p>
                        </div>
                    </label>
                </div>

            </div>
            
            <!-- ç­‰ç´šå‡ç´šé¸å–® (éš±è— by default) -->
            <div id="upgrade-menu" class="hidden text-left mb-6 space-y-3">
                <p class="text-xl font-bold mb-3 text-lime-400">é¸æ“‡å¼·åŒ–æ¨¡çµ„ [LEVEL UP]:</p>
                <div id="upgrade-options" class="space-y-3">
                    <!-- Upgrades will be inserted here -->
                </div>
            </div>

            <button id="modal-button" class="w-full py-4 text-2xl font-bold rounded-lg control-btn">
                [å•Ÿå‹•] é–å®šé…ç½®ï¼Œé–‹å§‹ä½œæˆ°ï¼
            </button>
        </div>
    </div>
</div>

<script>
    // --- æ­¦å™¨é…ç½® (ä¸è®Š) ---
    const WEAPONS = {
        'blaster': { cooldown: 10, bulletSize: 4, bulletColor: '#ff33ff', bulletHeightMultiplier: 6, damage: 1 }, 
        'cannon': { cooldown: 25, bulletSize: 8, bulletColor: '#FFFF00', bulletHeightMultiplier: 4, damage: 3 }, 
        'rapid': { cooldown: 4, bulletSize: 3, bulletColor: '#00FFFF', bulletHeightMultiplier: 8, damage: 0.5 } 
    };

    // --- æŠ€èƒ½é…ç½® (ä¸è®Š) ---
    const SKILLS = {
        'megabomb': {
            name: 'å·¨å‹ç‚¸å½ˆ',
            initialCharges: 3,
            color: '#A855F7', 
            effect: function() {
                const canvasCenterX = canvas.width / 2;
                const canvasCenterY = canvas.height / 2;
                for (let i = 0; i < 50; i++) {
                    createParticle(canvasCenterX, canvasCenterY, SKILLS[gameState.currentSkillId].color);
                }
                gameState.enemies.forEach(enemy => {
                    createExplosion(enemy.x, enemy.y, enemy.color);
                    gainXP(CFG.XP_PER_KILL); 
                    gameState.score += CFG.SCORE_PER_KILL; 
                });
                gameState.enemies = []; 
                triggerScreenShake(30);
                updateInfoDisplay();
            }
        },
        'shield': {
            name: 'æ™‚ç©ºè­·ç›¾',
            initialCharges: 2,
            color: '#3b82f6',
            effect: function() {
                gameState.isInvulnerable = true;
                gameState.shieldDuration = 180; // 3 seconds * 60 FPS
                triggerScreenShake(10);
            }
        }
    };
    
    // --- å‡ç´šé…ç½® ---
    const UPGRADES = [
        {
            id: 'damage',
            name: 'ç«åŠ›å¼·åŒ– (DMG Up)',
            description: 'æ°¸ä¹…å¢åŠ å­å½ˆå‚·å®³ 20%ã€‚',
            icon: 'ğŸ’¥',
            apply: (state) => { state.upgrades.damageMultiplier += 0.2; }
        },
        {
            id: 'firerate',
            name: 'å°„é€Ÿå„ªåŒ– (Rate Up)',
            description: 'æ°¸ä¹…ç¸®çŸ­ä¸»æ­¦å™¨å†·å»æ™‚é–“ 10%ã€‚',
            icon: 'âš¡',
            apply: (state) => { state.upgrades.fireRateMultiplier *= 0.9; }
        },
        {
            id: 'maxlife',
            name: 'ç”Ÿå‘½æ¨¡çµ„ (+1 Max Life)',
            description: 'æ°¸ä¹…å¢åŠ  1 é»æœ€å¤§ç”Ÿå‘½å€¼ï¼Œä¸¦ç«‹å³è£œæ»¿ã€‚',
            icon: 'â¤ï¸',
            apply: (state) => { 
                state.upgrades.maxLivesBonus += 1; 
                state.maxLives = CFG.MAX_LIVES + state.upgrades.maxLivesBonus;
                state.lives = state.maxLives; 
            }
        },
        {
            id: 'skillcharge',
            name: 'æŠ€èƒ½å……èƒ½ (+1 Charge)',
            description: 'ç«‹å³ç²å¾— 1 æ¬¡è¶…ç´šæŠ€èƒ½å……èƒ½ã€‚',
            icon: 'ğŸ”‹',
            apply: (state) => { state.skillCharges += 1; updateSkillButton(); }
        },
        {
            id: 'speed',
            name: 'æ©Ÿå‹•å¼·åŒ– (Speed Up)',
            description: 'æ°¸ä¹…å¢åŠ æˆ°æ©Ÿç§»å‹•é€Ÿåº¦ 15%ã€‚',
            icon: 'ğŸš€',
            apply: (state) => { state.upgrades.speedMultiplier *= 1.15; }
        }
    ];

    // éŠæˆ²é…ç½® (å‹•æ…‹é›£åº¦ç›¸é—œ)
    let CFG = {
        BULLET_SPEED: 15,
        ENEMY_BASE_SPEED: 2.5,
        ENEMY_SIZE: 45, 
        ENEMY_SPAWN_RATE: 80, 
        MAX_LIVES: 3,
        SCORE_PER_KILL: 10,
        MAX_PARTICLES: 300, 
        CANVAS_ASPECT_RATIO: 1 / 1.5,
        NUM_STARS: 150, 
        MAX_STAR_SPEED: 5,
        
        // --- ç¶“é©—å€¼èˆ‡é›£åº¦ä¿‚æ•¸ ---
        XP_PER_KILL: 1, 
        BASE_ENEMY_HEALTH: 1,
        ENEMY_HEALTH_PER_LEVEL: 0.5, // æ•µäººè¡€é‡æ¯ç´šå¢åŠ  0.5
        BASE_XP_TO_LEVEL: 5,
        XP_INCREASE_PER_LEVEL: 2,
    };

    // ç²å– DOM å…ƒç´ 
    const canvas = document.getElementById('gameCanvas');
    let ctx = null; 
    const infoScore = document.getElementById('score');
    const infoLives = document.getElementById('lives');
    const infoLevel = document.getElementById('level');
    const infoXPBar = document.getElementById('xp-bar');
    const infoXPText = document.getElementById('xp-text');
    const modal = document.getElementById('message-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalMessage = document.getElementById('modal-message');
    const modalButton = document.getElementById('modal-button');
    const startMenu = document.getElementById('start-menu');
    const upgradeMenu = document.getElementById('upgrade-menu');
    const upgradeOptions = document.getElementById('upgrade-options');
    const skillButton = document.getElementById('skill-button');
    const skillNameDisplay = document.getElementById('skill-name');
    const skillCountDisplay = document.getElementById('skill-count');
    const gameContainer = document.getElementById('game-container');


    // éŠæˆ²ç‹€æ…‹
    let gameState = {
        running: false,
        score: 0,
        maxLives: CFG.MAX_LIVES, // ç¾åœ¨æœ€å¤§ç”Ÿå‘½å€¼æœƒè®Šå‹•
        lives: CFG.MAX_LIVES,
        player: null,
        bullets: [],
        enemies: [],
        particles: [],
        stars: [], 
        enemySpawnCounter: 0,
        shakeTime: 0,
        targetX: 0,
        isShooting: false, 
        shootCooldown: 0,
        currentWeaponId: 'blaster', 
        currentSkillId: 'megabomb', 
        skillCharges: 0,
        isInvulnerable: false, 
        shieldDuration: 0,
        
        // --- ç¶“é©—å€¼èˆ‡å‡ç´šç‹€æ…‹ ---
        level: 1,
        xp: 0,
        xpToNextLevel: CFG.BASE_XP_TO_LEVEL,
        isUpgrading: false,
        upgrades: {
            damageMultiplier: 1,
            fireRateMultiplier: 1,
            maxLivesBonus: 0,
            speedMultiplier: 1,
        },
    };

    // --- æ˜Ÿæ˜Ÿç‰©ä»¶å·¥å»  (ä¸è®Š) ---
    function createStar() {
        const z = Math.random(); 
        const speed = 1 + z * CFG.MAX_STAR_SPEED; 
        const size = 1 + z * 1.5; 
        return {
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: size,
            speed: speed,
            color: z > 0.7 ? '#FFFFFF' : (z > 0.4 ? '#00FFFF' : '#ff33ff')
        };
    }
    function drawStar(star) {
        if (!ctx) return;
        ctx.fillStyle = star.color;
        ctx.shadowColor = star.color;
        ctx.shadowBlur = star.size * 2;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    function updateStar(star) {
        star.y += star.speed;
        if (star.y > canvas.height) {
            star.y = 0;
            star.x = Math.random() * canvas.width;
            const z = Math.random(); 
            star.speed = 1 + z * CFG.MAX_STAR_SPEED;
            star.size = 1 + z * 1.5;
            star.color = z > 0.7 ? '#FFFFFF' : (z > 0.4 ? '#00FFFF' : '#ff33ff');
        }
    }


    // --- ç¹ªè£½å‡½æ•¸ (å°å¹…ä¿®æ”¹æ•µäººç¹ªè£½ä»¥é¡¯ç¤º HP) ---
    function drawPlayer(p) {
        if (!ctx) return;
        
        // 1. ç¹ªè£½è­·ç›¾å…‰æšˆ (å¦‚æœç„¡æ•µ)
        if (gameState.isInvulnerable) {
            const glowRadius = p.width * 1.5;
            const glowOpacity = 0.5 + Math.sin(Date.now() / 100) * 0.2; 
            ctx.fillStyle = `rgba(59, 130, 246, ${glowOpacity})`; 
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 40;
            ctx.beginPath();
            ctx.arc(p.x, p.y + p.height / 4, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // 2. ç¹ªè£½æˆ°æ©Ÿä¸»é«” (ä¸è®Š)
        ctx.fillStyle = '#0a011a'; 
        ctx.strokeStyle = '#00FFFF'; 
        ctx.lineWidth = 2;
        ctx.shadowColor = '#00FFFF';
        ctx.shadowBlur = 20; 
        
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - p.height / 2); 
        ctx.lineTo(p.x - p.width / 2, p.y + p.height / 2); 
        ctx.lineTo(p.x + p.width / 2, p.y + p.height / 2); 
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.shadowBlur = 0; 

        // 3. ç¹ªè£½æ¨é€²å™¨ (ä¸è®Š)
        if (gameState.running) {
            const flameHeight = 15 + Math.random() * 10;
            const flameWidth = p.width * 0.5;
            
            ctx.fillStyle = `rgba(100, 255, 255, 0.9)`;
            ctx.beginPath();
            ctx.moveTo(p.x - flameWidth / 4, p.y + p.height / 2 - 5);
            ctx.lineTo(p.x + flameWidth / 4, p.y + p.height / 2 - 5);
            ctx.lineTo(p.x, p.y + p.height / 2 + flameHeight * 0.5); 
            ctx.fill();

            ctx.fillStyle = `rgba(0, 255, 255, 0.4)`;
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(p.x - flameWidth / 2, p.y + p.height / 2 - 2);
            ctx.lineTo(p.x + flameWidth / 2, p.y + p.height / 2 - 2);
            ctx.lineTo(p.x, p.y + p.height / 2 + flameHeight); 
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    function drawBullet(b) {
        if (!ctx) return;
        const weapon = WEAPONS[b.weaponId];
        const bulletWidth = b.radius * 2;
        const bulletHeight = b.radius * weapon.bulletHeightMultiplier * 1.5; 
        
        ctx.fillStyle = weapon.bulletColor; 
        ctx.shadowColor = weapon.bulletColor;
        ctx.shadowBlur = 30; 
        
        ctx.fillRect(b.x - bulletWidth / 2, b.y - bulletHeight / 2, bulletWidth, bulletHeight);
        
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(b.x - 1, b.y - bulletHeight / 2, 2, bulletHeight);

        ctx.shadowBlur = 0;
    }

    function drawEnemy(e) {
        if (!ctx) return;
        
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.rotate(e.angle); 

        const halfW = e.width / 2;
        const halfH = e.height / 2;
        const primaryColor = e.color; 
        const secondaryColor = '#FFFFFF'; 

        // 1. ä¸»æ©Ÿèº«å¤–æ¡†èˆ‡å…‰æšˆ
        ctx.strokeStyle = primaryColor;
        ctx.lineWidth = 2.5;
        ctx.shadowColor = primaryColor;
        ctx.shadowBlur = 20;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; 

        ctx.beginPath();
        ctx.moveTo(0, -halfH * 0.8);       
        ctx.lineTo(halfW, halfH * 0.5);    
        ctx.lineTo(halfW * 0.3, halfH);    
        ctx.lineTo(-halfW * 0.3, halfH);   
        ctx.lineTo(-halfW, halfH * 0.5);   
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        ctx.shadowBlur = 0; 

        // 2. è„ˆè¡æ¨é€²å™¨
        const pulse = Math.sin(Date.now() / 80) * 0.5 + 0.5;
        const thrusterColor = (primaryColor === '#FF4500' ? '#FFD700' : '#FF33FF');
        
        ctx.fillStyle = `rgba(255, 100, 255, ${0.5 + pulse * 0.5})`;
        ctx.shadowColor = thrusterColor;
        ctx.shadowBlur = 15 + pulse * 10; 

        const thrusterWidth = halfW * 0.2;
        const thrusterHeight = halfH * 0.3;
        
        ctx.fillRect(-halfW * 0.35, halfH * 0.8, thrusterWidth, thrusterHeight);
        ctx.fillRect(halfW * 0.15, halfH * 0.8, thrusterWidth, thrusterHeight);
        
        ctx.shadowBlur = 0;

        // 3. ä¸­å¤®é§•é§›è‰™/æ ¸å¿ƒ
        const coreSize = halfW * 0.2;
        ctx.fillStyle = secondaryColor; 
        ctx.shadowColor = primaryColor;
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.restore(); 
        
        // 4. ç¹ªè£½ç”Ÿå‘½æ¢ (åœ¨æ•µæ©Ÿä¸Šæ–¹)
        const hpBarWidth = e.width * 0.8;
        const hpBarHeight = 3;
        const hpRatio = e.health / e.maxHealth;
        const barX = e.x - hpBarWidth / 2;
        const barY = e.y - e.height / 2 - 8;

        ctx.fillStyle = '#4b5563'; // èƒŒæ™¯ç°è‰²
        ctx.fillRect(barX, barY, hpBarWidth, hpBarHeight);
        
        ctx.fillStyle = hpRatio > 0.5 ? '#10b981' : (hpRatio > 0.2 ? '#f59e0b' : '#ef4444'); // ç¶ /é»ƒ/ç´…
        ctx.fillRect(barX, barY, hpBarWidth * hpRatio, hpBarHeight);
    }

    function drawParticle(p) {
        if (!ctx) return;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = p.life > 30 ? 8 : 0; 
        ctx.fillRect(p.x, p.y, p.size, p.size);
        ctx.shadowBlur = 0;
    }
    
    // --- éŠæˆ²ç‰©ä»¶å·¥å»  ---
    const PlayerObject = {
        width: 45, height: 55, x: 0, y: 0, 
        init(x, y) { this.x = x; this.y = y; gameState.targetX = x; },
        draw: function() { drawPlayer(this); },
        update() {
            // æ ¹æ“šé€Ÿåº¦å‡ç´šèª¿æ•´ç§»å‹•é€Ÿåº¦
            const speed = 15 * gameState.upgrades.speedMultiplier; 
            const diff = gameState.targetX - this.x;
            if (Math.abs(diff) > speed) {
                this.x += Math.sign(diff) * speed;
            } else {
                this.x = gameState.targetX;
            }
            
            if (this.x < this.width / 2) this.x = this.width / 2;
            else if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
        }
    };
    function createBullet(x, y, weaponId) {
        const weapon = WEAPONS[weaponId];
        return {
            x: x, y: y - PlayerObject.height / 2, radius: weapon.bulletSize, weaponId: weaponId,
            damage: weapon.damage, // åŸºç¤å‚·å®³
            draw: function() { drawBullet(this); },
            update() { this.y -= CFG.BULLET_SPEED; }
        };
    }
    function createEnemy(x, y) {
        const colors = ['#FF4500', '#FFD700', '#FF00FF']; 
        
        // æ ¹æ“šç©å®¶ç­‰ç´šè¨ˆç®—æ•µäººç”Ÿå‘½å€¼
        const baseHealth = CFG.BASE_ENEMY_HEALTH + (gameState.level - 1) * CFG.ENEMY_HEALTH_PER_LEVEL;
        const health = Math.ceil(baseHealth); // ç¢ºä¿è¡€é‡æ˜¯æ•´æ•¸
        
        return {
            x: x, y: y, width: CFG.ENEMY_SIZE, height: CFG.ENEMY_SIZE, color: colors[Math.floor(Math.random() * colors.length)],
            angle: 0,
            rotationSpeed: (Math.random() - 0.5) * 0.03,
            health: health,
            maxHealth: health,
            draw: function() { drawEnemy(this); },
            update() { 
                this.y += CFG.ENEMY_BASE_SPEED; // æ•µäººç§»å‹•é€Ÿåº¦ä¸éš¨ç­‰ç´šè®ŠåŒ–
                this.angle += this.rotationSpeed;
            },
            getBounds() { return { x: this.x - this.width / 2, y: this.y - this.height / 2, width: this.width, height: this.height }; }
        };
    }
    function createParticle(x, y, color) {
        return {
            x, y, size: Math.random() * 4 + 1, color, 
            vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5, life: 70, 
            draw: function() { drawParticle(this); },
            update() {
                this.x += this.vx; this.y += this.vy; this.life--;
            }
        };
    }

    // --- éŠæˆ²é‚è¼¯èˆ‡ç‹€æ…‹ç®¡ç† ---
    
    function useSkill() {
        if (!gameState.running || gameState.skillCharges <= 0) {
            return;
        }
        if (gameState.currentSkillId === 'shield' && gameState.isInvulnerable) {
            return; 
        }

        const skill = SKILLS[gameState.currentSkillId];
        if (skill && skill.effect) {
            skill.effect(); 
            gameState.skillCharges--;
            updateSkillButton();
        }
    }
    function createExplosion(x, y, color) {
        for (let i = 0; i < 20; i++) { 
            if (gameState.particles.length < CFG.MAX_PARTICLES) {
                gameState.particles.push(createParticle(x, y, color));
            }
        }
    }
    function triggerScreenShake(duration) {
        gameState.shakeTime = duration;
    }
    
    // --- ç¶“é©—å€¼èˆ‡å‡ç´šç³»çµ± ---
    function getXPToNextLevel(level) {
        return CFG.BASE_XP_TO_LEVEL + (level - 1) * CFG.XP_INCREASE_PER_LEVEL;
    }

    function gainXP(amount) {
        if (gameState.isUpgrading) return;
        gameState.xp += amount;
        
        if (gameState.xp >= gameState.xpToNextLevel) {
            levelUp();
        }
        updateInfoDisplay(); 
    }

    function levelUp() {
        gameState.level++;
        gameState.xp = gameState.xp - gameState.xpToNextLevel; // è™•ç†æº¢å‡ºç¶“é©—
        gameState.xpToNextLevel = getXPToNextLevel(gameState.level);
        
        // ç¢ºä¿å¦‚æœæº¢å‡ºç¶“é©—è¶³å¤ å†å‡ä¸€ç´šï¼Œå‰‡ç¹¼çºŒå‡ç´š (é˜²æ­¢éŠæˆ²å¡ä½)
        if (gameState.xp >= gameState.xpToNextLevel) {
            levelUp();
            return;
        }

        gameState.running = false;
        gameState.isUpgrading = true;
        showUpgradeModal();
    }
    
    // --- æ ¸å¿ƒéŠæˆ²è¿´åœˆ ---
    function gameLoop() {
        if (!gameState.running || !ctx) return; 
        
        if (gameState.shakeTime > 0) {
            canvas.style.transform = `translate(${Math.random() * 6 - 3}px, ${Math.random() * 6 - 3}px)`; 
            gameState.shakeTime--;
        } else {
            canvas.style.transform = 'translate(0, 0)';
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        updateGameObjects();
        drawGameObjects();

        if (gameState.lives <= 0) {
            endGame(`[GAME OVER] ä½œæˆ°å¤±æ•— (LV.${gameState.level})`, `æ‚¨ä½¿ç”¨ ${SKILLS[gameState.currentSkillId].name} æŠ€èƒ½ï¼Œæœ€çµ‚å¾—åˆ† ${gameState.score} åˆ†ï¼`);
            return;
        }

        requestAnimationFrame(gameLoop);
    }
    
    function updateGameObjects() {
        // æ›´æ–°æ˜Ÿæ˜Ÿ
        gameState.stars.forEach(star => updateStar(star));

        // è­·ç›¾è¨ˆæ™‚å™¨
        if (gameState.isInvulnerable && gameState.shieldDuration > 0) {
            gameState.shieldDuration--;
            if (gameState.shieldDuration <= 0) {
                gameState.isInvulnerable = false;
            }
        }

        gameState.player.update();
        const currentWeapon = WEAPONS[gameState.currentWeaponId];
        // æ‡‰ç”¨å°„é€Ÿå¼·åŒ–ä¹˜æ•¸
        const currentCooldown = Math.max(2, Math.floor(currentWeapon.cooldown * gameState.upgrades.fireRateMultiplier)); 
        
        if (gameState.isShooting) {
            gameState.shootCooldown--;
            if (gameState.shootCooldown <= 0) {
                shoot();
                gameState.shootCooldown = currentCooldown;
            }
        }
        gameState.bullets = gameState.bullets.filter(bullet => { bullet.update(); return bullet.y > -bullet.radius; });
        gameState.particles = gameState.particles.filter(p => { p.update(); return p.life > 0; });
        
        gameState.enemySpawnCounter++;
        if (gameState.enemySpawnCounter >= CFG.ENEMY_SPAWN_RATE) {
            spawnEnemy();
            gameState.enemySpawnCounter = 0;
        }

        // æ•µæ©Ÿæ›´æ–°èˆ‡ç¢°æ’æª¢æŸ¥ (èˆ‡ç©å®¶åº•ç·š)
        gameState.enemies = gameState.enemies.filter(enemy => {
            enemy.update();
            if (enemy.y + enemy.height / 2 >= canvas.height - gameState.player.height) {
                if (!gameState.isInvulnerable) { 
                    gameState.lives--;
                    triggerScreenShake(20);
                    updateInfoDisplay();
                } else {
                    gainXP(CFG.XP_PER_KILL);
                    gameState.score += CFG.SCORE_PER_KILL; 
                }
                
                createExplosion(enemy.x, enemy.y, enemy.color);
                return false; 
            }
            return true;
        });
        
        handleCollisions();
    }

    function drawGameObjects() {
        if (!ctx) return;
        
        // 1. ç¹ªè£½æµå‹•çš„æ˜Ÿå ´
        gameState.stars.forEach(star => drawStar(star));

        // 2. ç¹ªè£½éŠæˆ²ç‰©ä»¶
        gameState.enemies.forEach(enemy => enemy.draw());
        gameState.bullets.forEach(bullet => bullet.draw());
        gameState.player.draw();
        gameState.particles.forEach(p => p.draw());
    }

    function handleCollisions() {
        const bulletsToRemove = new Set();
        const enemiesToRemove = new Set();
        
        // æ‡‰ç”¨ç©å®¶å‚·å®³ä¹˜æ•¸
        const damageMultiplier = gameState.upgrades.damageMultiplier; 
        
        for (let i = 0; i < gameState.bullets.length; i++) {
            const bullet = gameState.bullets[i];
            const weapon = WEAPONS[bullet.weaponId];
            const bulletCollisionHeight = bullet.radius * weapon.bulletHeightMultiplier * 1.5; 
            const bulletCollisionWidth = bullet.radius * 2;
            
            // è¨ˆç®—å­å½ˆçš„å¯¦éš›å‚·å®³
            const actualDamage = bullet.damage * damageMultiplier; 

            for (let j = 0; j < gameState.enemies.length; j++) {
                const enemy = gameState.enemies[j];
                // å¦‚æœæ•µäººå·²ç¶“è¢«å…¶ä»–å­å½ˆæ¨™è¨˜ç§»é™¤ï¼Œå‰‡è·³é
                if (enemiesToRemove.has(j)) continue; 
                
                const eBounds = enemy.getBounds();

                if (bullet.x + bulletCollisionWidth / 2 > eBounds.x &&
                    bullet.x - bulletCollisionWidth / 2 < eBounds.x + eBounds.width &&
                    bullet.y + bulletCollisionHeight / 2 > eBounds.y &&
                    bullet.y - bulletCollisionHeight / 2 < eBounds.y + eBounds.height) {
                    
                    bulletsToRemove.add(i); // å­å½ˆç¸½æ˜¯ç§»é™¤
                    
                    enemy.health -= actualDamage; // æ‰£é™¤å‚·å®³
                    
                    if (enemy.health <= 0) {
                        enemiesToRemove.add(j);
                        gainXP(CFG.XP_PER_KILL);
                        gameState.score += CFG.SCORE_PER_KILL;
                        createExplosion(enemy.x, enemy.y, enemy.color);
                    } else {
                         // å‘½ä¸­ç‰¹æ•ˆ
                        createExplosion(bullet.x, bullet.y, '#FF0000'); 
                    }
                    // æ‰¾åˆ°äº†ç¢°æ’ï¼Œè·³å‡ºå…§å±¤è¿´åœˆï¼Œè™•ç†ä¸‹ä¸€é¡†å­å½ˆ
                    break;
                }
            }
        }
        gameState.bullets = gameState.bullets.filter((_, index) => !bulletsToRemove.has(index));
        gameState.enemies = gameState.enemies.filter((_, index) => !enemiesToRemove.has(index));
    }
    
    function spawnEnemy() {
        const x = Math.random() * (canvas.width - CFG.ENEMY_SIZE) + CFG.ENEMY_SIZE / 2;
        const y = -CFG.ENEMY_SIZE;
        gameState.enemies.push(createEnemy(x, y));
    }
    function shoot() {
        if (!gameState.running) return;
        gameState.bullets.push(createBullet(gameState.player.x, gameState.player.y, gameState.currentWeaponId));
    }

    // --- è³‡è¨Šèˆ‡ç‹€æ…‹æ›´æ–° ---
    function updateInfoDisplay() {
        infoScore.textContent = gameState.score;
        infoLives.textContent = gameState.lives;
        infoLives.style.color = gameState.lives > 1 ? '#14b8a6' : '#ff4444'; 
        infoScore.style.color = '#00FFFF'; 
        
        // æ›´æ–°ç­‰ç´šèˆ‡ç¶“é©—å€¼é¡¯ç¤º
        infoLevel.textContent = gameState.level;
        const xpPercent = Math.min(100, (gameState.xp / gameState.xpToNextLevel) * 100);
        infoXPBar.style.width = `${xpPercent}%`;
        infoXPText.textContent = `${gameState.xp}/${gameState.xpToNextLevel} XP (ä¸‹ä¸€ç´š)`;
    }
    function updateSkillButton() {
        const skill = SKILLS[gameState.currentSkillId];
        skillNameDisplay.textContent = skill.name;
        skillCountDisplay.textContent = gameState.skillCharges;
        skillButton.disabled = gameState.skillCharges <= 0;
    }
    
    // --- æ¨¡æ…‹è¦–çª—è™•ç† ---
    function showModal(title, message) {
        modalTitle.textContent = title;
        modalMessage.textContent = message;
        modal.classList.remove('hidden');
    }
    function hideModal() {
        modal.classList.add('hidden');
    }

    function showStartMenu() {
        startMenu.classList.remove('hidden');
        upgradeMenu.classList.add('hidden');
        modalButton.textContent = '[å•Ÿå‹•] é–å®šé…ç½®ï¼Œé–‹å§‹ä½œæˆ°ï¼';
        modalButton.onclick = startGame;
        showModal('[ç³»çµ±å°±ç·’] åˆå§‹åŒ–', 'é¸æ“‡ä½ çš„é«˜èƒ½æ­¦å™¨å’Œè¶…ç´šæŠ€èƒ½ï¼Œæº–å‚™é€²å…¥æˆ°å€ã€‚');
    }

    function showUpgradeModal() {
        startMenu.classList.add('hidden');
        upgradeMenu.classList.remove('hidden');
        modalButton.textContent = 'ç¹¼çºŒæˆ°é¬¥';
        modalButton.onclick = continueGame;
        
        showModal(`[æ­å–œ] å‡ç´šè‡³ LV.${gameState.level}`, 'è«‹é¸æ“‡ä¸€é …æˆ°æ©Ÿå¼·åŒ–ï¼š');
        
        renderUpgradeOptions();
    }
    
    function renderUpgradeOptions() {
        upgradeOptions.innerHTML = ''; // æ¸…ç©ºèˆŠé¸é …
        
        // éš¨æ©Ÿé¸æ“‡ 3 å€‹ä¸é‡è¤‡çš„å‡ç´š
        const shuffledUpgrades = [...UPGRADES].sort(() => 0.5 - Math.random());
        const options = shuffledUpgrades.slice(0, 3);
        
        options.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'upgrade-card flex flex-col items-center p-3 transition duration-150';
            card.innerHTML = `
                <span class="text-3xl mb-1">${upgrade.icon}</span>
                <p class="font-bold text-lg text-yellow-300 mb-1">${upgrade.name}</p>
                <p class="text-sm text-gray-400 text-center">${upgrade.description}</p>
            `;
            
            card.onclick = () => selectUpgrade(upgrade);
            upgradeOptions.appendChild(card);
        });
    }

    function selectUpgrade(upgrade) {
        upgrade.apply(gameState); // æ‡‰ç”¨å‡ç´šæ•ˆæœ
        continueGame(); 
    }
    
    function continueGame() {
        gameState.isUpgrading = false;
        hideModal();
        gameState.running = true;
        // å¦‚æœéŠæˆ²è¿´åœˆå°šæœªå•Ÿå‹•ï¼Œå‰‡å•Ÿå‹•
        if (gameState.lives > 0) {
            requestAnimationFrame(gameLoop);
        }
    }
    
    // --- éŠæˆ²æµç¨‹æ§åˆ¶ ---
    function initGame() {
        if (!ctx) { ctx = canvas.getContext('2d'); }
        resizeCanvas();

        const selectedWeaponElement = document.querySelector('input[name="weapon"]:checked');
        const selectedSkillElement = document.querySelector('input[name="skill"]:checked');
        gameState.currentWeaponId = selectedWeaponElement ? selectedWeaponElement.value : 'blaster';
        gameState.currentSkillId = selectedSkillElement ? selectedSkillElement.value : 'megabomb';
        gameState.skillCharges = SKILLS[gameState.currentSkillId].initialCharges;
        
        // é‡ç½®æ‰€æœ‰è®Šæ•¸
        gameState.score = 0;
        gameState.level = 1;
        gameState.xp = 0;
        gameState.xpToNextLevel = getXPToNextLevel(1);
        gameState.upgrades = { damageMultiplier: 1, fireRateMultiplier: 1, maxLivesBonus: 0, speedMultiplier: 1 };
        gameState.maxLives = CFG.MAX_LIVES; 
        gameState.lives = gameState.maxLives;
        
        gameState.isInvulnerable = false;
        gameState.shieldDuration = 0;
        gameState.isUpgrading = false;
        gameState.bullets = [];
        gameState.enemies = [];
        gameState.particles = [];
        gameState.enemySpawnCounter = 0;
        gameState.shootCooldown = 0;
        
        gameState.player = PlayerObject;
        gameState.player.init(canvas.width / 2, canvas.height - 70); 
        
        updateInfoDisplay();
        updateSkillButton(); 
        hideModal();
    }

    function startGame() {
        if (gameState.running) return;
        initGame();
        gameState.running = true;
        requestAnimationFrame(gameLoop); 
    }

    function endGame(title, message) {
        gameState.running = false;
        showStartMenu(); 
        showModal(title, message);
    }

    // --- éŸ¿æ‡‰å¼å’Œè¼¸å…¥è™•ç† (ä¿®æ­£ resizeCanvas è®“å®ƒæ›´ç©©å®š) ---
    function resizeCanvas() {
        // ä½¿ç”¨ window.innerHeight ç¢ºä¿åœ¨è¡Œå‹•è£ç½®ä¸Šæº–ç¢ºç²å–å¯è¦–å€åŸŸé«˜åº¦
        const windowHeight = window.innerHeight; 
        const windowWidth = window.innerWidth;
        
        // è¨ˆç®—æ‰€æœ‰é Canvas UI å…ƒç´ çš„é«˜åº¦
        const headerHeight = document.querySelector('h1')?.offsetHeight || 0;
        const pHeight = document.querySelector('p')?.offsetHeight || 0;
        const infoBarHeight = infoScore?.parentElement?.offsetHeight || 0;
        const xpBarHeight = infoXPBar?.parentElement?.offsetHeight || 0;
        const skillButtonHeight = skillButton?.parentElement?.offsetHeight || 0;
        
        // ä¼°è¨ˆæ‰€æœ‰ä¸Šä¸‹é‚Šè·å’Œé–“éš™ (body padding-top: 1rem, padding-bottom: 1rem, h1/p margin, etc.)
        const totalUIMargin = 40; 
        
        const totalUIHeight = headerHeight + pHeight + infoBarHeight + xpBarHeight + skillButtonHeight + totalUIMargin;

        // å®¹å™¨å·¦å³ 1rem padding = 32px
        const availableWidth = Math.min(windowWidth - 32, 600); 
        const availableHeight = windowHeight - totalUIHeight; 
        
        const targetRatio = CFG.CANVAS_ASPECT_RATIO; 

        let newWidth, newHeight;

        // å„ªå…ˆä»¥å®¹å™¨çš„å¯¬åº¦è¨ˆç®—
        newWidth = availableWidth;
        newHeight = availableWidth / targetRatio;

        // å¦‚æœè¨ˆç®—å‡ºçš„é«˜åº¦è¶…éå¯ç”¨é«˜åº¦ï¼Œå‰‡ä»¥å¯ç”¨é«˜åº¦ç‚ºåŸºæº–
        if (newHeight > availableHeight) {
            newHeight = availableHeight;
            newWidth = newHeight * targetRatio;
        }

        newWidth = Math.max(newWidth, 200); // æœ€å°å¯¬åº¦
        newHeight = Math.max(newHeight, 300); // æœ€å°é«˜åº¦

        canvas.width = newWidth;
        canvas.height = newHeight;
        
        // è¨­ç½®ç•«å¸ƒçš„ style å°ºå¯¸ï¼Œä½¿å…¶åœ¨å®¹å™¨ä¸­å±…ä¸­ä¸¦é©æ‡‰
        canvas.style.width = `${newWidth}px`;
        canvas.style.height = `${newHeight}px`;

        if (gameState.player) {
            gameState.player.init(canvas.width / 2, canvas.height - 70);
        }
        
        // æ˜Ÿæ˜Ÿåˆå§‹åŒ–
        if (gameState.stars.length === 0) {
            gameState.stars = [];
            for (let i = 0; i < CFG.NUM_STARS; i++) {
                gameState.stars.push(createStar());
            }
        }
    }

    function handlePointerMove(e) {
        e.preventDefault(); // é˜²æ­¢ç§»å‹•æ™‚é é¢æ»¾å‹•
        if (!gameState.running) return;
        const x = getCanvasPos(e);
        gameState.targetX = x;
    }

    function handlePointerDown(e) {
        e.preventDefault(); // é˜²æ­¢è§¸ç™¼åŸç”Ÿç€è¦½å™¨è¡Œç‚º
        if (!gameState.running || gameState.isUpgrading) return;
        
        // é»æ“Šå³å°„æ“Š
        gameState.isShooting = true;
        gameState.shootCooldown = 0;

        const x = getCanvasPos(e);
        gameState.targetX = x;
    }

    function handlePointerUp(e) {
        e.preventDefault();
        if (!gameState.running) return;
        gameState.isShooting = false;
        gameState.shootCooldown = 0;
    }

    function getCanvasPos(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX = e.clientX;
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºè§¸æ§äº‹ä»¶
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
        }

        const x = clientX - rect.left;
        return x * (canvas.width / rect.width); // ç¸®æ”¾åˆ°ç•«å¸ƒåº§æ¨™ç³»
    }


    window.addEventListener('resize', resizeCanvas);
    
    window.onload = function() {
        ctx = canvas.getContext('2d');
        resizeCanvas();
        
        function animateMenu() {
            if (gameState.running) {
                if (gameState.player && gameState.player.x === 0 && canvas.width > 0) {
                    gameState.player.init(canvas.width / 2, canvas.height - 70);
                }
                return;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            gameState.stars.forEach(star => updateStar(star));
            gameState.stars.forEach(star => drawStar(star));
            
            const tempEnemy = {
                x: canvas.width / 2, y: canvas.height / 3, width: CFG.ENEMY_SIZE * 1.5, height: CFG.ENEMY_SIZE * 1.5, 
                color: '#FFD700', angle: (Date.now() / 2000) * 0.5, rotationSpeed: 0,
                health: 5, maxHealth: 5 // ç‚ºäº†å±•ç¤ºç”Ÿå‘½æ¢
            };
            drawEnemy(tempEnemy); 

            requestAnimationFrame(animateMenu);
        }
        animateMenu();
        
        showStartMenu(); 
        
        // --- ç¶å®šæ‰€æœ‰äº‹ä»¶ (åŒæ™‚æ”¯æ´æ»‘é¼ å’Œè§¸æ§) ---
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mouseup', handlePointerUp);
        
        // é‡å°ç§»å‹•è¨­å‚™çš„è§¸æ§äº‹ä»¶ï¼Œä½¿ç”¨ passive: false ä¾†ç¢ºä¿ preventDefault() æœ‰æ•ˆ
        canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
        canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
        canvas.addEventListener('touchend', handlePointerUp);
        canvas.addEventListener('touchcancel', handlePointerUp);

        skillButton.addEventListener('click', useSkill);

        document.addEventListener('keydown', (e) => {
            if (!gameState.running) return;
            if (e.key === ' ' || e.key.toLowerCase() === 'space') {
                e.preventDefault();
                gameState.isShooting = true;
            }
            if (e.key.toLowerCase() === 'b') {
                 useSkill();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!gameState.running) return;
            if (e.key === ' ' || e.key.toLowerCase() === 'space') {
                gameState.isShooting = false;
            }
        });
    };

</script>
</body>
</html>